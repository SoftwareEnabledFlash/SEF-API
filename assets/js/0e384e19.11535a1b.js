"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[671],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),f=a,m=d["".concat(s,".").concat(f)]||d[f]||u[f]||r;return n?i.createElement(m,o(o({ref:t},p),{},{components:n})):i.createElement(m,o({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9881:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),o=["components"],l={slug:"/",sidebar_position:1},s="Introduction",c={unversionedId:"intro",id:"intro",title:"Introduction",description:"chap-Introduction}",source:"@site/docs/intro.md",sourceDirName:".",slug:"/",permalink:"/SEF-API/",tags:[],version:"current",sidebarPosition:1,frontMatter:{slug:"/",sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Definitions and Acronyms",permalink:"/SEF-API/definitions"}},p={},u=[{value:"Figure 1: SEF Library Application Stack",id:"fig-SefComponentDiagram",level:4},{value:"Figure 2: SEF Block Diagram",id:"fig-SEFBlockDiagram",level:4}],d={toc:u};function f(e){var t=e.components,l=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"chap-Introduction"},"Introduction"),(0,r.kt)("p",null,"This specification describes the core components of the Software-Enabled Flash\u2122\ufe0f (SEF) application\nprogramming interface (API).\nThe SEF API provides a simple but powerful interface for developers that abstracts low-level flash\ndetails of low-level flash memory device mechanics in such a way that allows hosts to interact with\nflash memory devices as though they were simple performance-optimized read/write devices. Hosts\ncan make use of the SEF API to implement a custom Flash Translation Layer (FTL) or build\nSEF native applications bypassing all file systems in accordance with their application-specific\nrequirements.\nThe SEF API interfaces with SEF Units. SEF Units are PCIe\xae\ufe0f based NVMe\u2122\ufe0f devices\nthat implement the SEF specific extensions to the NVMe Base Specification. These extensions are\nseparately defined as the SEF Command Set.\nThe SEF API addresses the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Maintaining interface compatibility across flash memory generations"),(0,r.kt)("li",{parentName:"ul"},"Allowing host control over data placement to enable application-specific optimizations"),(0,r.kt)("li",{parentName:"ul"},"Providing mechanisms to enforce hardware isolation to support multi-tenancy and workload isolation"),(0,r.kt)("li",{parentName:"ul"},"Provides control over housekeeping functions to support predictable latency"),(0,r.kt)("li",{parentName:"ul"},"Reduces CPU cycles and host overhead via powerful API primitives"),(0,r.kt)("li",{parentName:"ul"},"Improves flash memory life and health via intelligent automatic resource allocation")),(0,r.kt)("p",null,"The SEF Library implements the SEF API as a linkable library module. The following figure\n",(0,r.kt)("a",{parentName:"p",href:"#fig-SefComponentDiagram"},"1")," illustrates where the SEF Library is located in the context of\na traditional SSD-like application stack. It shows multiple possible integrations of the SEF Library.\nIn some cases the integration is direct like with a SEF enable FIO. Other cases require a host-define\nFTL exposed to applications as a virtual block device in a QEMU guest. Tooling can also use the\nSEF Library for configuring SEF units with a command line interface. In all cases, the SEF Library\naccepts admin and I/O requests and issues a set of commands to the SEF Unit. The SEF Unit then\ntranslates this down to an appropriate set of flash memory-level operations and returns status and\ndata back up the stack."),(0,r.kt)("h4",{id:"fig-SefComponentDiagram"},"Figure 1: SEF Library Application Stack"),(0,r.kt)("p",null,(0,r.kt)("img",{loading:"lazy",alt:"SEF Library Application Stack",src:n(4705).Z,width:"961",height:"415"})),(0,r.kt)("p",null,"The SEF Unit handles functionality including super block allocation, identifying and working\naround defective blocks, low-level flash memory I/O, scheduling, prioritization and other device-level\nconcerns. The host layer in turn is responsible for implementing its own data placement strategy\n(including devising an appropriate logical-to-physical address mapping) as well as coordinating\nhousekeeping functions such as wear leveling, garbage collection, and responding to asynchronous\nevent notifications. The following figure ",(0,r.kt)("a",{parentName:"p",href:"#fig-SEFBlockDiagram"},"2")," provides a detailed view of\ndata flow within a SEF Unit."),(0,r.kt)("h4",{id:"fig-SEFBlockDiagram"},"Figure 2: SEF Block Diagram"),(0,r.kt)("p",null,(0,r.kt)("img",{loading:"lazy",alt:"SEF Block Diagram",src:n(8214).Z,width:"3791",height:"2769"})),(0,r.kt)("p",null,"Built in conjunction with the SEF API is a SEF SDK that provides a starting point for host\napplication development. The SEF SDK includes quick start guides for tooling to setup SEF devices\nfor use, sample drivers, libraries, supporting documentation, and an implementation of a fully\nfunctional Reference FTL that can be extended or modified as appropriate. It is documented\nseparately."))}f.isMDXComponent=!0},4705:function(e,t,n){t.Z=n.p+"assets/images/component-diagram-ee0e29af294ddcc0781970c0c623eaaf.png"},8214:function(e,t,n){t.Z=n.p+"assets/images/sef-block-diagram-00dc924f5f51dfd2cd39eb82c7ac476a.png"}}]);