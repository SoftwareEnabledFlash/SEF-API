"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[3605],{3905:(e,t,o)=>{o.d(t,{Zo:()=>c,kt:()=>h});var a=o(7294);function n(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function i(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function r(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?i(Object(o),!0).forEach((function(t){n(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,a,n=function(e,t){if(null==e)return{};var o,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)o=i[a],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)o=i[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var l=a.createContext({}),d=function(e){var t=a.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):r(r({},t),e)),o},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var o=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(o),u=n,h=p["".concat(l,".").concat(u)]||p[u]||m[u]||i;return o?a.createElement(h,r(r({ref:t},c),{},{components:o})):a.createElement(h,r({ref:t},c))}));function h(e,t){var o=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=o.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:n,r[1]=s;for(var d=2;d<i;d++)r[d]=o[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,o)}u.displayName="MDXCreateElement"},2463:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=o(7462),n=(o(7294),o(3905));const i={sidebar_position:7},r="QoS Domains",s={unversionedId:"qos-domains",id:"version-1.10/qos-domains",title:"QoS Domains",description:"A QoS domain is the mechanism used to access data within a SEF device. QoS domains are created",source:"@site/versioned_docs/version-1.10/qos-domains.md",sourceDirName:".",slug:"/qos-domains",permalink:"/SEF-API/1.10/qos-domains",draft:!1,tags:[],version:"1.10",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Virtual Devices",permalink:"/SEF-API/1.10/virtual-devices"},next:{title:"Super Pages",permalink:"/SEF-API/1.10/super-pages"}},l={},d=[{value:"Figure 8.1: QoS Domain Example",id:"figure-81-qos-domain-example",level:4},{value:"Creation-time Parameters",id:"creation-time-parameters",level:2}],c={toc:d},p="wrapper";function m(e){let{components:t,...i}=e;return(0,n.kt)(p,(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"qos-domains"},"QoS Domains"),(0,n.kt)("p",null,"A QoS domain is the mechanism used to access data within a SEF device. QoS domains are created\nwithin a virtual device, and it is possible to have multiple QoS domains sharing a single virtual\ndevice. When multiple QoS domains share a virtual device, they will draw from a common pool of\nsuper blocks. However a super block is never shared between QoS domains and so data for QoS\ndomains will never be intermingled in a super block. When QoS domains share a virtual device,\nthere is no hardware isolation between them, so die-time conflicts are possible. The scheduling and\nprioritization features of SEF are used to order I/O for shared virtual devices and to resolve these\ndie-time conflicts (e.g. software-defined isolation/quality of service)."),(0,n.kt)("p",null,"When a QoS domain is created, several parameters are specified to define the characteristics of the\nQoS domain, which will be discussed below. Upon successful creation of a QoS domain, a device\nnode will be created in the operating system namespace corresponding to the newly created QoS\ndomain. At boot time the SEF device driver will create device nodes for all QoS domains previously\ndefined for the device. Device nodes for QoS domains may be used to enumerate existing QoS\ndomains as well as to restrict access to/enforce ownership of a QoS domain. All user data access\ncommands are issued against a QoS domain. Typically, a QoS domain will be used by a single\napplication or Flash Translation Layer/block driver/key value driver."),(0,n.kt)("p",null,"Figure 8.1 shows an example of how the virtual devices of a SEF Unit could be divided into QoS\ndomains. A QoS domain is a logical construct that defines a capacity taken from its virtual device\u2019s\ncapacity. It also defines a quota that may exceed the capacity of the virtual device as shown with\nQoS domains three through four. A SEF Unit can have at most 65534 QoS domains defined. The\nactual limit depends on specific hardware limitations."),(0,n.kt)("p",null,"Allocated super blocks are owned by only one QoS domain at a time and never shared. Super blocks\nare allocated from a shared pool allowing for host-managed thin provisioning. A QoS domain can\nallocate super blocks until it hits its quota or the free pool is exhausted."),(0,n.kt)("h4",{id:"figure-81-qos-domain-example"},"Figure 8.1: QoS Domain Example"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"QoS Domain Example",src:o(7035).Z,width:"869",height:"529"})),(0,n.kt)("h2",{id:"creation-time-parameters"},"Creation-time Parameters"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"vdHandle"),": the handle to the virtual device the QoS domain will be created in."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"QoSDomainID"),": an identifier that will later be used to specify the created QoS domain. This\nidentifier must be unique across the entire SEF device. IDs 0 and 1 are reserved."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"flashCapacity"),": the number of ADUs reserved for the QoS domain. It is subtracted from the\navailable ADUs from the virtual device so must be less than the currently available ADUs."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"flashQuota"),": the quota for the amount of space this QoS domain may consume. The value is\nspecified as the total number of ADUs. If less than flashCapacity, it will be set to flashCapacity.\nSince a super block is never shared between QoS domains, the actual capacity allocated for the QoS\ndomain may be greater than requested to fill out an entire super block."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"ADUsize"),": this is the ADU size requested for this QoS domain. Different QoS domains, even within\nthe same virtual device, may have different ADU sizes. A list of supported ADU sizes for a SEF\ndevice may be queried from the SEF device."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"api"),": this field specifies the API to be used for this QoS domain. Currently only the super block\nAPI is supported."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"recovery"),": Specifies the error recovery strategy for this QoS domain."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"encryption"),": specifies that the QoS domain is to be encrypted."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"numRootPointers"),": specifies the number of user defined metadata pointers to be created for this\nQoS domain. A typical use for this would be to preserve metadata for the QoS domain within the\nQoS domain itself. For example, an L2P lookup table for a block FTL could be written/persisted\nwithin the QoS domain, keeping track of the physical addresses of the table. ADUs could then be\nwritten containing a tree of pointers to all of the ADUs making up the table, and finally the root\npointer of the tree of pointers could be saved. At initialization time the root pointer could be read\nto restore the entire table. Up to 16 root pointers may be saved per QoS domain."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"numPlacementIDs"),": specifies the number of separate, simultaneously opened super blocks that\nmay be used by the QoS domain in auto allocation mode. It does not affect the number of manually\nopened super blocks, which instead depends on the device itself."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"FMQDefaults"),": specifies the default FMQ to use for each type of I/O operation. This can be\noptionally overridden when submitting I/O to a QoS domain."))}m.isMDXComponent=!0},7035:(e,t,o)=>{o.d(t,{Z:()=>a});const a=o.p+"assets/images/qos-domain-example-fdadb5c12d23039c0223d5a956707753.png"}}]);