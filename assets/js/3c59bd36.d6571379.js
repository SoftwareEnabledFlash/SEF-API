"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[931],{3905:function(t,e,a){a.d(e,{Zo:function(){return p},kt:function(){return k}});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var u=n.createContext({}),s=function(t){var e=n.useContext(u),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},p=function(t){var e=s(t.components);return n.createElement(u.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},m=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,u=t.parentName,p=o(t,["components","mdxType","originalType","parentName"]),m=s(a),k=r,S=m["".concat(u,".").concat(k)]||m[k]||d[k]||l;return a?n.createElement(S,i(i({ref:e},p),{},{components:a})):n.createElement(S,i({ref:e},p))}));function k(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=m;var o={};for(var u in e)hasOwnProperty.call(e,u)&&(o[u]=e[u]);o.originalType=t,o.mdxType="string"==typeof t?t:r,i[1]=o;for(var s=2;s<l;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},2671:function(t,e,a){a.r(e),a.d(e,{assets:function(){return p},contentTitle:function(){return u},default:function(){return k},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return d}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),i=["components"],o={},u="API Management Commands",s={unversionedId:"SEF_API/sef-api00",id:"version-1.10/SEF_API/sef-api00",title:"API Management Commands",description:"SEFLibraryInit",source:"@site/versioned_docs/version-1.10/SEF_API/sef-api00.md",sourceDirName:"SEF_API",slug:"/SEF_API/sef-api00",permalink:"/SEF-API/1.10/SEF_API/sef-api00",draft:!1,tags:[],version:"1.10",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Addressing",permalink:"/SEF-API/1.10/addressing"},next:{title:"Data Access Commands",permalink:"/SEF-API/1.10/SEF_API/sef-api01"}},p={},d=[{value:"SEFLibraryInit",id:"function-SEFLibraryInit",level:2},{value:"Return value of SEFLibraryInit",id:"return-value-of-seflibraryinit",level:4},{value:"SEFGetHandle",id:"function-SEFGetHandle",level:2},{value:"Parameters of SEFGetHandle",id:"parameters-of-sefgethandle",level:4},{value:"Return value of SEFGetHandle",id:"return-value-of-sefgethandle",level:4},{value:"SEFLibraryCleanup",id:"function-SEFLibraryCleanup",level:2},{value:"Return value of SEFLibraryCleanup",id:"return-value-of-seflibrarycleanup",level:4},{value:"SEFGetInformation",id:"function-SEFGetInformation",level:2},{value:"Parameters of SEFGetInformation",id:"parameters-of-sefgetinformation",level:4},{value:"Return value of SEFGetInformation",id:"return-value-of-sefgetinformation",level:4},{value:"SEFListVirtualDevices",id:"function-SEFListVirtualDevices",level:2},{value:"Parameters of SEFListVirtualDevices",id:"parameters-of-seflistvirtualdevices",level:4},{value:"Return value of SEFListVirtualDevices",id:"return-value-of-seflistvirtualdevices",level:4},{value:"SEFListQoSDomains",id:"function-SEFListQoSDomains",level:2},{value:"Parameters of SEFListQoSDomains",id:"parameters-of-seflistqosdomains",level:4},{value:"Return value of SEFListQoSDomains",id:"return-value-of-seflistqosdomains",level:4},{value:"SEFCreateVirtualDevice",id:"function-SEFCreateVirtualDevice",level:2},{value:"Parameters of SEFCreateVirtualDevice",id:"parameters-of-sefcreatevirtualdevice",level:4},{value:"Return value of SEFCreateVirtualDevice",id:"return-value-of-sefcreatevirtualdevice",level:4},{value:"SEFGetVirtualDeviceInformation",id:"function-SEFGetVirtualDeviceInformation",level:2},{value:"Parameters of SEFGetVirtualDeviceInformation",id:"parameters-of-sefgetvirtualdeviceinformation",level:4},{value:"Return value of SEFGetVirtualDeviceInformation",id:"return-value-of-sefgetvirtualdeviceinformation",level:4},{value:"SEFCreateQoSDomain",id:"function-SEFCreateQoSDomain",level:2},{value:"Parameters of SEFCreateQoSDomain",id:"parameters-of-sefcreateqosdomain",level:4},{value:"Return value of SEFCreateQoSDomain",id:"return-value-of-sefcreateqosdomain",level:4},{value:"SEFSetQoSDomainCapacity",id:"function-SEFSetQoSDomainCapacity",level:2},{value:"Parameters of SEFSetQoSDomainCapacity",id:"parameters-of-sefsetqosdomaincapacity",level:4},{value:"Return value of SEFSetQoSDomainCapacity",id:"return-value-of-sefsetqosdomaincapacity",level:4},{value:"SEFSetRootPointer",id:"function-SEFSetRootPointer",level:2},{value:"Parameters of SEFSetRootPointer",id:"parameters-of-sefsetrootpointer",level:4},{value:"Return value of SEFSetRootPointer",id:"return-value-of-sefsetrootpointer",level:4},{value:"SEFSetReadDeadline",id:"function-SEFSetReadDeadline",level:2},{value:"Parameters of SEFSetReadDeadline",id:"parameters-of-sefsetreaddeadline",level:4},{value:"Return value of SEFSetReadDeadline",id:"return-value-of-sefsetreaddeadline",level:4},{value:"SEFGetQoSDomainInformation",id:"function-SEFGetQoSDomainInformation",level:2},{value:"Parameters of SEFGetQoSDomainInformation",id:"parameters-of-sefgetqosdomaininformation",level:4},{value:"Return value of SEFGetQoSDomainInformation",id:"return-value-of-sefgetqosdomaininformation",level:4},{value:"SEFGetReuseList",id:"function-SEFGetReuseList",level:2},{value:"Parameters of SEFGetReuseList",id:"parameters-of-sefgetreuselist",level:4},{value:"Return value of SEFGetReuseList",id:"return-value-of-sefgetreuselist",level:4},{value:"SEFGetRefreshList",id:"function-SEFGetRefreshList",level:2},{value:"Parameters of SEFGetRefreshList",id:"parameters-of-sefgetrefreshlist",level:4},{value:"Return value of SEFGetRefreshList",id:"return-value-of-sefgetrefreshlist",level:4},{value:"SEFGetCheckList",id:"function-SEFGetCheckList",level:2},{value:"Parameters of SEFGetCheckList",id:"parameters-of-sefgetchecklist",level:4},{value:"Return value of SEFGetCheckList",id:"return-value-of-sefgetchecklist",level:4},{value:"SEFGetUserAddressList",id:"function-SEFGetUserAddressList",level:2},{value:"Parameters of SEFGetUserAddressList",id:"parameters-of-sefgetuseraddresslist",level:4},{value:"Return value of SEFGetUserAddressList",id:"return-value-of-sefgetuseraddresslist",level:4},{value:"SEFGetSuperBlockInfo",id:"function-SEFGetSuperBlockInfo",level:2},{value:"Parameters of SEFGetSuperBlockInfo",id:"parameters-of-sefgetsuperblockinfo",level:4},{value:"Return value of SEFGetSuperBlockInfo",id:"return-value-of-sefgetsuperblockinfo",level:4},{value:"SEFCheckPage",id:"function-SEFCheckPage",level:2},{value:"Parameters of SEFCheckPage",id:"parameters-of-sefcheckpage",level:4},{value:"Return value of SEFCheckPage",id:"return-value-of-sefcheckpage",level:4},{value:"SEFDeleteVirtualDevice",id:"function-SEFDeleteVirtualDevice",level:2},{value:"Parameters of SEFDeleteVirtualDevice",id:"parameters-of-sefdeletevirtualdevice",level:4},{value:"Return value of SEFDeleteVirtualDevice",id:"return-value-of-sefdeletevirtualdevice",level:4},{value:"SEFDeleteQoSDomain",id:"function-SEFDeleteQoSDomain",level:2},{value:"Parameters of SEFDeleteQoSDomain",id:"parameters-of-sefdeleteqosdomain",level:4},{value:"Return value of SEFDeleteQoSDomain",id:"return-value-of-sefdeleteqosdomain",level:4},{value:"SEFResetEncryptionKey",id:"function-SEFResetEncryptionKey",level:2},{value:"Parameters of SEFResetEncryptionKey",id:"parameters-of-sefresetencryptionkey",level:4},{value:"Return value of SEFResetEncryptionKey",id:"return-value-of-sefresetencryptionkey",level:4},{value:"SEFOpenVirtualDevice",id:"function-SEFOpenVirtualDevice",level:2},{value:"Parameters of SEFOpenVirtualDevice",id:"parameters-of-sefopenvirtualdevice",level:4},{value:"Return value of SEFOpenVirtualDevice",id:"return-value-of-sefopenvirtualdevice",level:4},{value:"SEFCloseVirtualDevice",id:"function-SEFCloseVirtualDevice",level:2},{value:"Parameters of SEFCloseVirtualDevice",id:"parameters-of-sefclosevirtualdevice",level:4},{value:"Return value of SEFCloseVirtualDevice",id:"return-value-of-sefclosevirtualdevice",level:4},{value:"SEFOpenQoSDomain",id:"function-SEFOpenQoSDomain",level:2},{value:"Parameters of SEFOpenQoSDomain",id:"parameters-of-sefopenqosdomain",level:4},{value:"Return value of SEFOpenQoSDomain",id:"return-value-of-sefopenqosdomain",level:4},{value:"SEFCloseQoSDomain",id:"function-SEFCloseQoSDomain",level:2},{value:"Parameters of SEFCloseQoSDomain",id:"parameters-of-sefcloseqosdomain",level:4},{value:"Return value of SEFCloseQoSDomain",id:"return-value-of-sefcloseqosdomain",level:4},{value:"SEFParseFlashAddress",id:"function-SEFParseFlashAddress",level:2},{value:"Parameters of SEFParseFlashAddress",id:"parameters-of-sefparseflashaddress",level:4},{value:"Return value of SEFParseFlashAddress",id:"return-value-of-sefparseflashaddress",level:4},{value:"SEFCreateFlashAddress",id:"function-SEFCreateFlashAddress",level:2},{value:"Parameters of SEFCreateFlashAddress",id:"parameters-of-sefcreateflashaddress",level:4},{value:"Return value of SEFCreateFlashAddress",id:"return-value-of-sefcreateflashaddress",level:4},{value:"SEFReleaseSuperBlock",id:"function-SEFReleaseSuperBlock",level:2},{value:"Parameters of SEFReleaseSuperBlock",id:"parameters-of-sefreleasesuperblock",level:4},{value:"Return value of SEFReleaseSuperBlock",id:"return-value-of-sefreleasesuperblock",level:4},{value:"SEFAllocateSuperBlock",id:"function-SEFAllocateSuperBlock",level:2},{value:"Parameters of SEFAllocateSuperBlock",id:"parameters-of-sefallocatesuperblock",level:4},{value:"Return value of SEFAllocateSuperBlock",id:"return-value-of-sefallocatesuperblock",level:4},{value:"SEFFlushSuperBlock",id:"function-SEFFlushSuperBlock",level:2},{value:"Parameters of SEFFlushSuperBlock",id:"parameters-of-sefflushsuperblock",level:4},{value:"Return value of SEFFlushSuperBlock",id:"return-value-of-sefflushsuperblock",level:4},{value:"SEFCloseSuperBlock",id:"function-SEFCloseSuperBlock",level:2},{value:"Parameters of SEFCloseSuperBlock",id:"parameters-of-sefclosesuperblock",level:4},{value:"Return value of SEFCloseSuperBlock",id:"return-value-of-sefclosesuperblock",level:4},{value:"SEFPrepareBufferForNamelessCopy",id:"function-SEFPrepareBufferForNamelessCopy",level:2},{value:"Parameters of SEFPrepareBufferForNamelessCopy",id:"parameters-of-sefpreparebufferfornamelesscopy",level:4},{value:"Return value of SEFPrepareBufferForNamelessCopy",id:"return-value-of-sefpreparebufferfornamelesscopy",level:4},{value:"SEFFreeBufferForNamelessCopy",id:"function-SEFFreeBufferForNamelessCopy",level:2},{value:"Parameters of SEFFreeBufferForNamelessCopy",id:"parameters-of-seffreebufferfornamelesscopy",level:4},{value:"SEFReleaseSuperBlockAsync",id:"function-SEFReleaseSuperBlockAsync",level:2},{value:"Parameters of SEFReleaseSuperBlockAsync",id:"parameters-of-sefreleasesuperblockasync",level:4},{value:"SEFAllocateSuperBlockAsync",id:"function-SEFAllocateSuperBlockAsync",level:2},{value:"Parameters of SEFAllocateSuperBlockAsync",id:"parameters-of-sefallocatesuperblockasync",level:4},{value:"SEFCloseSuperBlockAsync",id:"function-SEFCloseSuperBlockAsync",level:2},{value:"Parameters of SEFCloseSuperBlockAsync",id:"parameters-of-sefclosesuperblockasync",level:4}],m={toc:d};function k(t){var e=t.components,a=(0,r.Z)(t,i);return(0,l.kt)("wrapper",(0,n.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"api-management-commands"},"API Management Commands"),(0,l.kt)("h2",{id:"function-SEFLibraryInit"},"SEFLibraryInit"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFLibraryInit(void)\n")),(0,l.kt)("p",null,"Initializes the SEF Library, enumerates the SEF Units present, and returns the number of units found.\nEvery successful call to SEFLibraryInit() must be balanced with a call to SEFLibraryCleanup()."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus"),", ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api00#function-SEFLibraryCleanup"}," SEFLibraryCleanup()")," "),(0,l.kt)("h4",{id:"return-value-of-seflibraryinit"},"Return value of SEFLibraryInit"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result. The 'info' member contains number of units.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFGetHandle"},"SEFGetHandle"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"SEFHandle SEFGetHandle(int index)\n")),(0,l.kt)("p",null,"Returns a handle to the SEF device at the specified index (zero based) "),(0,l.kt)("h4",{id:"parameters-of-sefgethandle"},"Parameters of SEFGetHandle"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"index"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Index of the SEF Unit")))),(0,l.kt)("h4",{id:"return-value-of-sefgethandle"},"Return value of SEFGetHandle"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFLibraryCleanup"},"SEFLibraryCleanup"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFLibraryCleanup(void)\n")),(0,l.kt)("p",null,"Performs cleanup of the SEF Library and releases resources. "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus"),", ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api00#function-SEFLibraryInit"}," SEFLibraryInit()")," "),(0,l.kt)("h4",{id:"return-value-of-seflibrarycleanup"},"Return value of SEFLibraryCleanup"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFGetInformation"},"SEFGetInformation"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"const struct SEFInfo* SEFGetInformation(SEFHandle sefHandle)\n")),(0,l.kt)("p",null,"Gets device information.\nReturns ADU size(s), number of channels, number of dies, and other associated information."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefgetinformation"},"Parameters of SEFGetInformation"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")))),(0,l.kt)("h4",{id:"return-value-of-sefgetinformation"},"Return value of SEFGetInformation"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const struct SEFInfo *"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFListVirtualDevices"},"SEFListVirtualDevices"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFListVirtualDevices(SEFHandle sefHandle, struct SEFVirtualDeviceList *list, int bufferSize)\n")),(0,l.kt)("p",null,"Returns a list of the defined Virtual Devices. "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-seflistvirtualdevices"},"Parameters of SEFListVirtualDevices"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFVirtualDeviceList *"),(0,l.kt)("td",{parentName:"tr",align:null},"list"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer for storing list of Virtual Devices")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"bufferSize"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer size")))),(0,l.kt)("h4",{id:"return-value-of-seflistvirtualdevices"},"Return value of SEFListVirtualDevices"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFListQoSDomains"},"SEFListQoSDomains"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFListQoSDomains(SEFHandle sefHandle, struct SEFQoSDomainList *list, int bufferSize)\n")),(0,l.kt)("p",null,"Returns a list of the defined QoS Domains. "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-seflistqosdomains"},"Parameters of SEFListQoSDomains"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainList *"),(0,l.kt)("td",{parentName:"tr",align:null},"list"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer for storing list of QoS Domains")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"bufferSize"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer size")))),(0,l.kt)("h4",{id:"return-value-of-seflistqosdomains"},"Return value of SEFListQoSDomains"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFCreateVirtualDevice"},"SEFCreateVirtualDevice"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFCreateVirtualDevice(SEFHandle sefHandle, struct SEFVirtualDeviceID virtualDeviceID, struct SEFDieMap dieMap, enum SEFDefectManagementMethod defectStrategy, uint8_t numFMQueues, const struct SEFWeights weights[])\n")),(0,l.kt)("p",null,"Creates a Virtual Device and allocates physical resources."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus"),", ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api00#function-SEFGetInformation"}," SEFGetInformation()")," "),(0,l.kt)("h4",{id:"parameters-of-sefcreatevirtualdevice"},"Parameters of SEFCreateVirtualDevice"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFVirtualDeviceID"),(0,l.kt)("td",{parentName:"tr",align:null},"virtualDeviceID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Virtual Device ID")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFDieMap"),(0,l.kt)("td",{parentName:"tr",align:null},"dieMap"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Dies requested for virtual device")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"enum SEFDefectManagementMethod"),(0,l.kt)("td",{parentName:"tr",align:null},"defectStrategy"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Defect management strategy for the Virtual Device")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint8_t"),(0,l.kt)("td",{parentName:"tr",align:null},"numFMQueues"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of Flash Media Queues per die in the Virtual Device")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const struct SEFWeights[]"),(0,l.kt)("td",{parentName:"tr",align:null},"weights"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Weight values for each Flash Media Queue")))),(0,l.kt)("h4",{id:"return-value-of-sefcreatevirtualdevice"},"Return value of SEFCreateVirtualDevice"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result. Returns 0 on success and negative value on error.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFGetVirtualDeviceInformation"},"SEFGetVirtualDeviceInformation"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFGetVirtualDeviceInformation(SEFHandle sefHandle, struct SEFVirtualDeviceID virtualDeviceID, struct SEFVirtualDeviceInfo *info, int bufferSize)\n")),(0,l.kt)("p",null,"Returns Virtual Device information. "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefgetvirtualdeviceinformation"},"Parameters of SEFGetVirtualDeviceInformation"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFVirtualDeviceID"),(0,l.kt)("td",{parentName:"tr",align:null},"virtualDeviceID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Virtual Device ID")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFVirtualDeviceInfo *"),(0,l.kt)("td",{parentName:"tr",align:null},"info"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer for storing VD information")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"bufferSize"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer size")))),(0,l.kt)("h4",{id:"return-value-of-sefgetvirtualdeviceinformation"},"Return value of SEFGetVirtualDeviceInformation"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFCreateQoSDomain"},"SEFCreateQoSDomain"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFCreateQoSDomain(SEFVDHandle vdHandle, struct SEFQoSDomainID QoSDomainID, uint64_t flashCapacity, uint64_t flashQuota, uint32_t ADUsize, enum SEFAPIIdentifier api, enum SEFErrorRecoveryMode recovery, int encryption, uint16_t numRootPointers, uint16_t numPlacementIDs, struct SEFFMQAssignments FMQDefaults)\n")),(0,l.kt)("p",null,"Attempts to create a QoS Domain in the specified Virtual Device.\nReturns an error when the target virtual device doesn\u2019t have enough flash memory space. When the flashQuota is less than the flashCapacity, it will be set to the flashCapacity."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api00#function-SEFGetInformation"},"SEFGetInformation()")," "),(0,l.kt)("h4",{id:"parameters-of-sefcreateqosdomain"},"Parameters of SEFCreateQoSDomain"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFVDHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"vdHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the Virtual Device")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"QoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"QoS Domain ID. Unique across all QoS Domains")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint64_t"),(0,l.kt)("td",{parentName:"tr",align:null},"flashCapacity"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of required/reserved ADUs")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint64_t"),(0,l.kt)("td",{parentName:"tr",align:null},"flashQuota"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of ADUs that can be allocated")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint32_t"),(0,l.kt)("td",{parentName:"tr",align:null},"ADUsize"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Size of ADU in this QoS domain in bytes. Must be one of the values in ADUSize[] in SEFInfo returned by SEFGetInformation(). SEF Unit should support 4kiB.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"enum SEFAPIIdentifier"),(0,l.kt)("td",{parentName:"tr",align:null},"api"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Specifies the API Identifier for this QoS domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"enum SEFErrorRecoveryMode"),(0,l.kt)("td",{parentName:"tr",align:null},"recovery"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Specifies the recovery mode for this QoS domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"encryption"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"0 for disabled, non-zero for enabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint16_t"),(0,l.kt)("td",{parentName:"tr",align:null},"numRootPointers"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Specifies the number of root pointers corresponding to this QoS domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint16_t"),(0,l.kt)("td",{parentName:"tr",align:null},"numPlacementIDs"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"The maximum number of Placement IDs that can be placed on the QoS domain. (The number of Placement IDs would affect memory usage)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFMQAssignments"),(0,l.kt)("td",{parentName:"tr",align:null},"FMQDefaults"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"The default die FMQ assignments for I/O commands")))),(0,l.kt)("h4",{id:"return-value-of-sefcreateqosdomain"},"Return value of SEFCreateQoSDomain"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFSetQoSDomainCapacity"},"SEFSetQoSDomainCapacity"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFSetQoSDomainCapacity(SEFQoSHandle qosHandle, uint64_t flashCapacity, uint64_t flashQutoa) \n")),(0,l.kt)("p",null,"Resets the capacity of a QoS Domain.\nSets a new capacity and quota for the QoS domain. When the flashQuota is less than the flashCapacity, it is set to the flashCapacity. Returns an error when the total capacity of assigned super blocks exceeds the new capacity."),(0,l.kt)("h4",{id:"parameters-of-sefsetqosdomaincapacity"},"Parameters of SEFSetQoSDomainCapacity"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint64_t"),(0,l.kt)("td",{parentName:"tr",align:null},"flashCapacity"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of required/reserved ADUs")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint64_t"),(0,l.kt)("td",{parentName:"tr",align:null},"flashQutoa"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of ADUs that can be allocated")))),(0,l.kt)("h4",{id:"return-value-of-sefsetqosdomaincapacity"},"Return value of SEFSetQoSDomainCapacity"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFSetRootPointer"},"SEFSetRootPointer"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFSetRootPointer(SEFQoSHandle qosHandle, int index, struct SEFFlashAddress value)\n")),(0,l.kt)("p",null,"Sets the physical address of the QoSDomain root ADU pointer.\nA root pointer may be set to any value. Root pointer values are read back using SEFGetQoSDomainInformation(). When a root pointer is set to a flash address that is valid for the QoS domain it's stored in, the ADU it points to can be read by SEFReadWithPhysicalAddress1() using a flash address of just the root pointer index as the ADU."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus"),", ",(0,l.kt)("a",{parentName:"p",href:"#function-SEFReadWithPhysicalAddress1"}," SEFReadWithPhysicalAddress1()")," "),(0,l.kt)("h4",{id:"parameters-of-sefsetrootpointer"},"Parameters of SEFSetRootPointer"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"index"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"The index of the root pointer")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFlashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"value"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Value of the pointer")))),(0,l.kt)("h4",{id:"return-value-of-sefsetrootpointer"},"Return value of SEFSetRootPointer"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFSetReadDeadline"},"SEFSetReadDeadline"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFSetReadDeadline(SEFQoSHandle qosHandle, enum SEFDeadlineType deadline) \n")),(0,l.kt)("p",null,"Sets target QoS Domain's read deadline policy. "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus"),", ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFVirtualDeviceInfo"},"struct  SEFVirtualDeviceInfo")," "),(0,l.kt)("h4",{id:"parameters-of-sefsetreaddeadline"},"Parameters of SEFSetReadDeadline"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"enum SEFDeadlineType"),(0,l.kt)("td",{parentName:"tr",align:null},"deadline"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Deadline type for this QoS domain")))),(0,l.kt)("h4",{id:"return-value-of-sefsetreaddeadline"},"Return value of SEFSetReadDeadline"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFGetQoSDomainInformation"},"SEFGetQoSDomainInformation"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFGetQoSDomainInformation(SEFHandle sefHandle, struct SEFQoSDomainID QoSDomainID, struct SEFQoSDomainInfo *info, int bufferSize)\n")),(0,l.kt)("p",null,"Returns QoS Domain information, including the list of super blocks assigned to the QoS Domain. "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefgetqosdomaininformation"},"Parameters of SEFGetQoSDomainInformation"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"QoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"QoS Domain ID")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainInfo *"),(0,l.kt)("td",{parentName:"tr",align:null},"info"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer for storing QoS Domain information")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"bufferSize"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer size")))),(0,l.kt)("h4",{id:"return-value-of-sefgetqosdomaininformation"},"Return value of SEFGetQoSDomainInformation"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFGetReuseList"},"SEFGetReuseList"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFGetReuseList(SEFQoSHandle qosHandle, struct SEFWearInfo *info, int bufferSize)\n")),(0,l.kt)("p",null,"Returns list of SuperBlocks to process for wear-leveling.\nUsed in support of the implementation of a host-specified wear leveling policy. SEF has a built in wear-leveling mechanism."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefgetreuselist"},"Parameters of SEFGetReuseList"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFWearInfo *"),(0,l.kt)("td",{parentName:"tr",align:null},"info"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer for storing information of blocks to process")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"bufferSize"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer size")))),(0,l.kt)("h4",{id:"return-value-of-sefgetreuselist"},"Return value of SEFGetReuseList"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFGetRefreshList"},"SEFGetRefreshList"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFGetRefreshList(SEFQoSHandle qosHandle, struct SEFRefreshInfo *info, int bufferSize) \n")),(0,l.kt)("p",null,"Returns a list of blocks that have encountered ECC errors.\nThese blocks subsequently need to be re-written, or else data loss may occur. This call should be part of a periodic background check to guard against data loss."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefgetrefreshlist"},"Parameters of SEFGetRefreshList"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFRefreshInfo *"),(0,l.kt)("td",{parentName:"tr",align:null},"info"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer for storing information of blocks to process")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"bufferSize"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer size")))),(0,l.kt)("h4",{id:"return-value-of-sefgetrefreshlist"},"Return value of SEFGetRefreshList"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFGetCheckList"},"SEFGetCheckList"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFGetCheckList(SEFQoSHandle qosHandle, struct SEFCheckInfo *info, int bufferSize) \n")),(0,l.kt)("p",null,"Returns a list of blocks that have encountered conditions that need to be checked.\nIn the event that this command indicates that blocks need to be checked, a subsequent patrol command (SEFCheckPage) should be issued in response. Detailed error statistics will be returned as part of the patrol, and appropriate corrective actions can be based on the returned information."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus"),", ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api00#function-SEFCheckPage"}," SEFCheckPage()")," "),(0,l.kt)("h4",{id:"parameters-of-sefgetchecklist"},"Parameters of SEFGetCheckList"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFCheckInfo *"),(0,l.kt)("td",{parentName:"tr",align:null},"info"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer for storing information of blocks to process")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"bufferSize"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer size")))),(0,l.kt)("h4",{id:"return-value-of-sefgetchecklist"},"Return value of SEFGetCheckList"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFGetUserAddressList"},"SEFGetUserAddressList"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFGetUserAddressList(SEFQoSHandle qosHandle, struct SEFFlashAddress flashAddress, struct SEFUserAddressRecord *list, int bufferSize)\n")),(0,l.kt)("p",null,"Returns the user address list in terms of its underlying superblocks.\nUsed as part of an FTL reconstruction activity. This can happen in the event of, for example, ungraceful shutdown. This mechanism can also be used to build custom diagnostic tools. This command is not needed during normal operation."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefgetuseraddresslist"},"Parameters of SEFGetUserAddressList"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFlashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"flashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Physical address of the superblock")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFUserAddressRecord *"),(0,l.kt)("td",{parentName:"tr",align:null},"list"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer for storing list of user addresses")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"bufferSize"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer size")))),(0,l.kt)("h4",{id:"return-value-of-sefgetuseraddresslist"},"Return value of SEFGetUserAddressList"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFGetSuperBlockInfo"},"SEFGetSuperBlockInfo"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFGetSuperBlockInfo(SEFQoSHandle qosHandle, struct SEFFlashAddress flashAddress, struct SEFSuperBlockRecord *info)\n")),(0,l.kt)("p",null,"Returns information corresponding to the superblock. "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefgetsuperblockinfo"},"Parameters of SEFGetSuperBlockInfo"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFlashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"flashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Physical address of the superblock")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFSuperBlockRecord *"),(0,l.kt)("td",{parentName:"tr",align:null},"info"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer for storing superblock information")))),(0,l.kt)("h4",{id:"return-value-of-sefgetsuperblockinfo"},"Return value of SEFGetSuperBlockInfo"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFCheckPage"},"SEFCheckPage"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFCheckPage(SEFQoSHandle qosHandle, struct SEFFlashAddress flashAddress) \n")),(0,l.kt)("p",null,"This is a read patrol operation which can be used in conjunction with SEFGetCheckList.\nReturns detailed information concerning checked pages to allow host software to take appropriate corrective actions."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus"),", ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api00#function-SEFGetCheckList"}," SEFGetCheckList()")," "),(0,l.kt)("h4",{id:"parameters-of-sefcheckpage"},"Parameters of SEFCheckPage"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFlashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"flashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Physical address to be checked")))),(0,l.kt)("h4",{id:"return-value-of-sefcheckpage"},"Return value of SEFCheckPage"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFDeleteVirtualDevice"},"SEFDeleteVirtualDevice"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFDeleteVirtualDevice(SEFHandle sefHandle, struct SEFVirtualDeviceID virtualDeviceID)\n")),(0,l.kt)("p",null,"Deletes the target virtual device.\nThe Virtual Device must be in the closed state before issuing this command. Moreover, this command will fail if the Virtual Device contains any QoS Domains."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefdeletevirtualdevice"},"Parameters of SEFDeleteVirtualDevice"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFVirtualDeviceID"),(0,l.kt)("td",{parentName:"tr",align:null},"virtualDeviceID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Virtual Device ID")))),(0,l.kt)("h4",{id:"return-value-of-sefdeletevirtualdevice"},"Return value of SEFDeleteVirtualDevice"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFDeleteQoSDomain"},"SEFDeleteQoSDomain"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFDeleteQoSDomain(SEFHandle sefHandle, struct SEFQoSDomainID QoSDomainID)\n")),(0,l.kt)("p",null,"Deletes the target QoS domain.\nThe QoS domain must be in the closed state before issuing this command. After closing the target QoS domain, its assigned superblocks are returned to the virtual device's free pool."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefdeleteqosdomain"},"Parameters of SEFDeleteQoSDomain"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"QoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"QoS Domain ID")))),(0,l.kt)("h4",{id:"return-value-of-sefdeleteqosdomain"},"Return value of SEFDeleteQoSDomain"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFResetEncryptionKey"},"SEFResetEncryptionKey"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFResetEncryptionKey(SEFHandle sefHandle, struct SEFQoSDomainID QoSDomainID) \n")),(0,l.kt)("p",null,"Resets the encryption key for a QoS Domain. "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefresetencryptionkey"},"Parameters of SEFResetEncryptionKey"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"QoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"QoS Domain ID")))),(0,l.kt)("h4",{id:"return-value-of-sefresetencryptionkey"},"Return value of SEFResetEncryptionKey"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFOpenVirtualDevice"},"SEFOpenVirtualDevice"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFOpenVirtualDevice(SEFHandle sefHandle, struct SEFVirtualDeviceID virtualDeviceID, void(*notifyFunc)(void *, struct SEFVDNotification), void *context, SEFVDHandle *vdHandle)\n")),(0,l.kt)("p",null,"Opens the target virtual device.\nSince Virtual Devices are persistent, this provides the mechanism for opening a preexisting Virtual Device to resume I/O after reboot. This function needs to be called in order to receive notifications about the virtual device, such as in the event that a reduced capacity notification is issued."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefopenvirtualdevice"},"Parameters of SEFOpenVirtualDevice"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFVirtualDeviceID"),(0,l.kt)("td",{parentName:"tr",align:null},"virtualDeviceID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Virtual Device ID")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"void(",(0,l.kt)("em",{parentName:"td"},")(void "),", struct SEFVDNotification)"),(0,l.kt)("td",{parentName:"tr",align:null},"notifyFunc"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback to be executed upon event generation")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"void *"),(0,l.kt)("td",{parentName:"tr",align:null},"context"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"A void* pointer passed to the async event notification function (used to pass user context information)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFVDHandle *"),(0,l.kt)("td",{parentName:"tr",align:null},"vdHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the Virtual Drive")))),(0,l.kt)("h4",{id:"return-value-of-sefopenvirtualdevice"},"Return value of SEFOpenVirtualDevice"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFCloseVirtualDevice"},"SEFCloseVirtualDevice"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFCloseVirtualDevice(SEFVDHandle vdHandle)\n")),(0,l.kt)("p",null,"Closes an open Virtual Device and shuts down associated event notification. "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefclosevirtualdevice"},"Parameters of SEFCloseVirtualDevice"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFVDHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"vdHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the Virtual Device")))),(0,l.kt)("h4",{id:"return-value-of-sefclosevirtualdevice"},"Return value of SEFCloseVirtualDevice"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFOpenQoSDomain"},"SEFOpenQoSDomain"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFOpenQoSDomain(SEFHandle sefHandle, struct SEFQoSDomainID QoSDomainID, void(*notifyFunc)(void *, struct SEFQoSNotification), void *context, const void *encryptionKey, SEFQoSHandle *qosHandle)\n")),(0,l.kt)("p",null,"Opens a previously created QoS Domain.\nSince QoS Domains are persistent, this provides the mechanism for opening a preexisting QoS Domain to resume I/O after reboot. This function also provides a channel to receive notifications regarding this QoS domain."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefopenqosdomain"},"Parameters of SEFOpenQoSDomain"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"QoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"QoS Domain ID")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"void(",(0,l.kt)("em",{parentName:"td"},")(void "),", struct SEFQoSNotification)"),(0,l.kt)("td",{parentName:"tr",align:null},"notifyFunc"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Callback to be executed during event generation")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"void *"),(0,l.kt)("td",{parentName:"tr",align:null},"context"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"A void* pointer passed to the async event notification function (used to pass user context information)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const void *"),(0,l.kt)("td",{parentName:"tr",align:null},"encryptionKey"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"In a multitenant environment, different tenants will write to separate QoS domains. Provides for individualized encryption keys on a per-domain basis")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle *"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")))),(0,l.kt)("h4",{id:"return-value-of-sefopenqosdomain"},"Return value of SEFOpenQoSDomain"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFCloseQoSDomain"},"SEFCloseQoSDomain"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFCloseQoSDomain(SEFQoSHandle qosHandle)\n")),(0,l.kt)("p",null,"Closes an open QoS Domain.\nThis in turn will close any open superblocks associated with this domain. All outstanding kSuperblockChangeState events will be delivered before this function returns. A QoS Domain must be in the closed state to be deleted."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefcloseqosdomain"},"Parameters of SEFCloseQoSDomain"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")))),(0,l.kt)("h4",{id:"return-value-of-sefcloseqosdomain"},"Return value of SEFCloseQoSDomain"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFParseFlashAddress"},"SEFParseFlashAddress"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFParseFlashAddress(SEFHandle sefHandle, struct SEFFlashAddress flashAddress, struct SEFQoSDomainID *QoSDomainID, uint16_t *blockNumber, uint32_t *ADUOffset)\n")),(0,l.kt)("p",null,"This function is used to extract info needed by FTL from an opaque flash address. "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefparseflashaddress"},"Parameters of SEFParseFlashAddress"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFlashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"flashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"The opaque address to be parsed")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainID *"),(0,l.kt)("td",{parentName:"tr",align:null},"QoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to where to return the QoS Domain ID. A null pointer indicates that the Qos Domain ID is not to be returned")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint16_t *"),(0,l.kt)("td",{parentName:"tr",align:null},"blockNumber"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to where to return the block number. A null pointer indicates that the block number is not to be returned")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint32_t *"),(0,l.kt)("td",{parentName:"tr",align:null},"ADUOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to where to return the ADU Offset. A null pointer indicates that the ADU Offset is not to be returned")))),(0,l.kt)("h4",{id:"return-value-of-sefparseflashaddress"},"Return value of SEFParseFlashAddress"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFCreateFlashAddress"},"SEFCreateFlashAddress"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFFlashAddress SEFCreateFlashAddress(SEFHandle sefHandle, struct SEFQoSDomainID QoSDomainID, uint16_t blockNumber, uint32_t ADUOffset)\n")),(0,l.kt)("p",null,"This function is used to create an opaque flash address.\nA generated flash address may be rejected by the device if it specifies an illegal ADUOffset, a block number not owned by the QoSDomainID, or a QoSDomainID that has not been opened by the caller."),(0,l.kt)("h4",{id:"parameters-of-sefcreateflashaddress"},"Parameters of SEFCreateFlashAddress"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"sefHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the SEF Unit")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"QoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"The desired QoS Domain ID.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint16_t"),(0,l.kt)("td",{parentName:"tr",align:null},"blockNumber"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"The desired block number.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint32_t"),(0,l.kt)("td",{parentName:"tr",align:null},"ADUOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"The desired ADU Offset.")))),(0,l.kt)("h4",{id:"return-value-of-sefcreateflashaddress"},"Return value of SEFCreateFlashAddress"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFlashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"The generated flash address.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFReleaseSuperBlock"},"SEFReleaseSuperBlock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFReleaseSuperBlock(SEFQoSHandle qosHandle, struct SEFFlashAddress flashAddress)\n")),(0,l.kt)("p",null,"Releases the specific Super Block to the free pool owned by the Virtual Device to which the specified QoS Domain belongs.\nThe target superblock must have been assigned by a previous call to SEFAllocateSuperBlock() or as part of SEFWriteWithoutPhysicalAddress1(). The superblock must be closed, otherwise the call will fail."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefreleasesuperblock"},"Parameters of SEFReleaseSuperBlock"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain of the Super Block")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFlashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"flashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Physical address of the superblock to release")))),(0,l.kt)("h4",{id:"return-value-of-sefreleasesuperblock"},"Return value of SEFReleaseSuperBlock"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFAllocateSuperBlock"},"SEFAllocateSuperBlock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFAllocateSuperBlock(SEFQoSHandle qosHandle, struct SEFFlashAddress *flashAddress, uint32_t retention, enum SEFSuperBlockType type, const struct SEFAllocateOverrides *overrides)\n")),(0,l.kt)("p",null,"Allocates a superblock that will be assigned to the specified QoS Domain and returns the physical address of this superblock.\nAny number of superblocks can be kept open for write for each QoS domain. These superblocks in turn can be used as part of the parameter set for SEFWriteWithoutPhysicalAddress(). When allocating a superblock, SEF intelligently selects a location in a manner designed to optimize the lifetime of flash memory and will return the physical address that was selected. Note that each open superblock will allocate a write buffer and therefore consume memory, so there is a tradeoff in the number of open superblocks and the amount of memory consumed.\nRequired that the total ADUs in the domain be less than its flash quota. This can be known by summing the writableADUs of each superblock in the domain."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus"),", ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api00#function-SEFGetQoSDomainInformation"}," SEFGetQoSDomainInformation()")," "),(0,l.kt)("h4",{id:"parameters-of-sefallocatesuperblock"},"Parameters of SEFAllocateSuperBlock"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFlashAddress *"),(0,l.kt)("td",{parentName:"tr",align:null},"flashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"The flash address of the allocated block")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint32_t"),(0,l.kt)("td",{parentName:"tr",align:null},"retention"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Retention period in hours")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"enum SEFSuperBlockType"),(0,l.kt)("td",{parentName:"tr",align:null},"type"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"kForWrite, kForCopy or kForDeviceMetadata")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const struct SEFAllocateOverrides *"),(0,l.kt)("td",{parentName:"tr",align:null},"overrides"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Overrides to scheduler parameters; pointer can be null for none required.")))),(0,l.kt)("h4",{id:"return-value-of-sefallocatesuperblock"},"Return value of SEFAllocateSuperBlock"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result. .info contains number of ADUs in allocated superblock")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFFlushSuperBlock"},"SEFFlushSuperBlock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFFlushSuperBlock(SEFQoSHandle qosHandle, struct SEFFlashAddress flashAddress, uint32_t *distanceToEndOfSuperBlock) \n")),(0,l.kt)("p",null,"Flushes the target superblock.\nThis command causes all written data for the superblock that is still in the write buffer and not persisted to flash memory to be persisted to flash memory. The device will automatically append data if necessary to finish programming of all pending user data writes. This command will not return until any address change notifications for the superblock being flushed have been processed, ensuring that all previously tentative addresses are now permanent."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefflushsuperblock"},"Parameters of SEFFlushSuperBlock"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain of the Super Block")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFlashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"flashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Physical address of the Super Block to be flushed.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint32_t *"),(0,l.kt)("td",{parentName:"tr",align:null},"distanceToEndOfSuperBlock"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"Indicates remaining size in ADU after this flush operation. May be NULL.")))),(0,l.kt)("h4",{id:"return-value-of-sefflushsuperblock"},"Return value of SEFFlushSuperBlock"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFCloseSuperBlock"},"SEFCloseSuperBlock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFCloseSuperBlock(SEFQoSHandle qosHandle, struct SEFFlashAddress flashAddress)\n")),(0,l.kt)("p",null,"Closes the target superblock.\nIf there is remaining unwritten space in the superblock, that space will be padded with dummy data. This can be used by the FTL as a means of closing a superblock without invoking a Write command.\nThis command will not return until all address change and superblock state change notifications for the superblock being closed have been processed, ensuring that all previously tentative addresses are now permanent."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api02#struct-SEFStatus"},"struct SEFStatus")," "),(0,l.kt)("h4",{id:"parameters-of-sefclosesuperblock"},"Parameters of SEFCloseSuperBlock"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain of the Super Block")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFFlashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"flashAddress"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Physical address of the Super Block to move to Closed state by filling data")))),(0,l.kt)("h4",{id:"return-value-of-sefclosesuperblock"},"Return value of SEFCloseSuperBlock"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFPrepareBufferForNamelessCopy"},"SEFPrepareBufferForNamelessCopy"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"void* SEFPrepareBufferForNamelessCopy(struct SEFCopySource *copySource, const struct SEFUserAddressFilter *filter, uint32_t numAddressChangeRecords, struct SEFAddressChangeRequest **addressChangeInfo)\n")),(0,l.kt)("p",null,"This function allocates a data buffer SEFNamelessCopy().\nIt initializes filter parameters and returns pointers into members of copySource and addressChangeInfo."),(0,l.kt)("h4",{id:"parameters-of-sefpreparebufferfornamelesscopy"},"Parameters of SEFPrepareBufferForNamelessCopy"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFCopySource *"),(0,l.kt)("td",{parentName:"tr",align:null},"copySource"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Description of copy source; format and arraysize MUST be initialized. The validBitmap pointer or flashAddressList pointer will be set by this function.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const struct SEFUserAddressFilter *"),(0,l.kt)("td",{parentName:"tr",align:null},"filter"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Pointer to filter parameters, may be null for no filtering. This function will set the filter fields in the buffer.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint32_t"),(0,l.kt)("td",{parentName:"tr",align:null},"numAddressChangeRecords"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Size of addressChangeRequest userAddress array")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFAddressChangeRequest **"),(0,l.kt)("td",{parentName:"tr",align:null},"addressChangeInfo"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to pointer to the address change info within the buffer (set by this function)")))),(0,l.kt)("h4",{id:"return-value-of-sefpreparebufferfornamelesscopy"},"Return value of SEFPrepareBufferForNamelessCopy"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"void *"),(0,l.kt)("td",{parentName:"tr",align:null},"Pointer to allocated buffer or NULL if error")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFFreeBufferForNamelessCopy"},"SEFFreeBufferForNamelessCopy"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"void SEFFreeBufferForNamelessCopy(void *copyContext)\n")),(0,l.kt)("p",null,"Frees the buffer allocated with SEFPrepareBufferForNamelessCopy(). "),(0,l.kt)("h4",{id:"parameters-of-seffreebufferfornamelesscopy"},"Parameters of SEFFreeBufferForNamelessCopy"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"void *"),(0,l.kt)("td",{parentName:"tr",align:null},"copyContext"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to the memory to free")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFReleaseSuperBlockAsync"},"SEFReleaseSuperBlockAsync"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"void SEFReleaseSuperBlockAsync(SEFQoSHandle qosHandle, struct SEFReleaseSuperBlockIOCB *iocb)\n")),(0,l.kt)("p",null,"This function is the asynchronous version of SEFReleaseSuperBlock(). "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api00#function-SEFReleaseSuperBlock"},"SEFReleaseSuperBlock()")," "),(0,l.kt)("h4",{id:"parameters-of-sefreleasesuperblockasync"},"Parameters of SEFReleaseSuperBlockAsync"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFReleaseSuperBlockIOCB *"),(0,l.kt)("td",{parentName:"tr",align:null},"iocb"),(0,l.kt)("td",{parentName:"tr",align:null},"In/Out"),(0,l.kt)("td",{parentName:"tr",align:null},"For asynchronous response from SEF Library Unused fields should be set to 0.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFAllocateSuperBlockAsync"},"SEFAllocateSuperBlockAsync"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"void SEFAllocateSuperBlockAsync(SEFQoSHandle qosHandle, struct SEFAllocateSuperBlockIOCB *iocb)\n")),(0,l.kt)("p",null,"This function is the asynchronous version of SEFAllocateSuperBlock(). "),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api00#function-SEFAllocateSuperBlock"},"SEFAllocateSuperBlock()")," "),(0,l.kt)("h4",{id:"parameters-of-sefallocatesuperblockasync"},"Parameters of SEFAllocateSuperBlockAsync"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFAllocateSuperBlockIOCB *"),(0,l.kt)("td",{parentName:"tr",align:null},"iocb"),(0,l.kt)("td",{parentName:"tr",align:null},"In/Out"),(0,l.kt)("td",{parentName:"tr",align:null},"For asynchronous response from SEF Library Unused fields should be set to 0.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFCloseSuperBlockAsync"},"SEFCloseSuperBlockAsync"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"void SEFCloseSuperBlockAsync(SEFQoSHandle qosHandle, struct SEFCloseSuperBlockIOCB *iocb)\n")),(0,l.kt)("p",null,"This function is the asynchronous version of SEFCloseSuperBlock().\nkSuperblockStateChanged will have been sent before the completion routine is called and the iocb is marked as done."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-API/1.10/SEF_API/sef-api00#function-SEFCloseSuperBlock"},"SEFCloseSuperBlock()")," "),(0,l.kt)("h4",{id:"parameters-of-sefclosesuperblockasync"},"Parameters of SEFCloseSuperBlockAsync"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFCloseSuperBlockIOCB *"),(0,l.kt)("td",{parentName:"tr",align:null},"iocb"),(0,l.kt)("td",{parentName:"tr",align:null},"In/Out"),(0,l.kt)("td",{parentName:"tr",align:null},"For asynchronous response from SEF Library")))),(0,l.kt)("hr",null))}k.isMDXComponent=!0}}]);