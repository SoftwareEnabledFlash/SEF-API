"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[352],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return p}});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(r),p=o,m=d["".concat(l,".").concat(p)]||d[p]||f[p]||a;return r?n.createElement(m,i(i({ref:t},u),{},{components:r})):n.createElement(m,i({ref:t},u))}));function p(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},6686:function(e,t,r){r.r(t),r.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return f}});var n=r(7462),o=r(3366),a=(r(7294),r(3905)),i=["components"],s={sidebar_position:4},l="Design Strategy",c={unversionedId:"strategy",id:"version-1.10/strategy",title:"Design Strategy",description:"The SEF library is stateless. Nearly all requests result in one or more requests to the SEF driver.",source:"@site/versioned_docs/version-1.10/strategy.md",sourceDirName:".",slug:"/strategy",permalink:"/SEF-API/1.10/strategy",tags:[],version:"1.10",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Design Environment",permalink:"/SEF-API/1.10/environment"},next:{title:"Software-Enabled Flash\u2122 (SEF) Unit",permalink:"/SEF-API/1.10/sef-unit"}},u={},f=[],d={toc:f};function p(e){var t=e.components,r=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"design-strategy"},"Design Strategy"),(0,a.kt)("p",null,"The SEF library is stateless. Nearly all requests result in one or more requests to the SEF driver.\nThose requests are submitted using the caller\u2019s thread. The completion of SEF driver requests\nis handled by an internal, statically sized thread pool based on the number of CPUs. Therefore,\ncompletion routines should not block on resources that require another completion routine to execute\nas that would risk deadlock. An example of a bad design is an I/O completion blocking waiting for\na different I/O request to complete first. The SEF library specifically will fail synchronous calls\ninto the SEF library from a completion routine for this reason. Of course, waiting for a resource\nowned by another completion thread won\u2019t cause deadlock, but it does reduce the number of threads\navailable to process completions."),(0,a.kt)("p",null,"Writes to a SEF device complete before the final flash memory address has been assigned. A\nnotification is sent if the final flash memory address is different than the preliminary address.\nHowever, no notification occurs when the preliminary flash memory address is the final flash\nmemory address. It can be inferred by the super block closed notification. As a result, metadata\nthat is tracking the allocated flash memory addresses is not final until the super block close\nnotification is processed. In the case of a power failure, up-to-date metadata structures can be\nrebuilt from the user address data supplied when the data was written."))}p.isMDXComponent=!0}}]);