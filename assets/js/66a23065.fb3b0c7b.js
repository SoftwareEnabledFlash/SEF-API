"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[4442],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(a),u=o,h=p["".concat(l,".").concat(u)]||p[u]||m[u]||i;return a?n.createElement(h,r(r({ref:t},c),{},{components:a})):n.createElement(h,r({ref:t},c))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:o,r[1]=s;for(var d=2;d<i;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},6858:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var n=a(7462),o=(a(7294),a(3905));const i={sidebar_position:6},r="QoS Domains",s={unversionedId:"qos-domains",id:"qos-domains",title:"QoS Domains",description:"chap-QoSDomain}",source:"@site/docs/qos-domains.md",sourceDirName:".",slug:"/qos-domains",permalink:"/SEF-API/qos-domains",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"docs",previous:{title:"Virtual Devices",permalink:"/SEF-API/virtual-devices"},next:{title:"Super Pages",permalink:"/SEF-API/super-pages"}},l={},d=[{value:"Figure 5: QoS Domain Example",id:"fig-QoSDomainExample",level:4},{value:"Creation-time Parameters",id:"creation-time-parameters",level:2}],c={toc:d},p="wrapper";function m(e){let{components:t,...i}=e;return(0,o.kt)(p,(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"chap-QoSDomain"},"QoS Domains"),(0,o.kt)("p",null,"A QoS domain is the mechanism used to access data within a SEF Unit. QoS domains are created\nwithin a virtual device, and it is possible to have multiple QoS domains sharing a single virtual\ndevice. When multiple QoS domains share a virtual device, they will draw from a common pool of\nsuper blocks. However a super block is never shared between QoS domains and so data for QoS\ndomains will never be intermingled in a super block. When QoS domains share a virtual device,\nthere is no hardware isolation between them, so die-time conflicts are possible. The scheduling and\nprioritization features of SEF are used to order I/O for shared virtual devices and to resolve these\ndie-time conflicts (e.g., software-defined isolation/quality of service)."),(0,o.kt)("p",null,"When a QoS domain is created, several parameters are specified to define the characteristics\nof the QoS domain, which will be discussed below. Upon successful creation of a QoS domain,\na device node will be created in the operating system namespace corresponding to the newly\ncreated QoS domain. It has a capacity and quota. The capacity is storage reserved in the virtual\ndevice for use by the QoS domain. The quota is how much total storage can be assigned to\nthe QoS domain. Initially the quota is set to the capacity, but both can be changed later using\n",(0,o.kt)("a",{parentName:"p",href:"/SEF-API/SEF_API/sef-api00#function-SEFSetQoSDomainCapacity"},"SEFSetQoSDomainCapacity"),". At boot time the SEF Unit\ndriver will create device nodes for all QoS domains previously defined for the device. Device nodes for\nQoS domains may be used to enumerate existing QoS domains as well as to restrict access to/enforce\nownership of a QoS domain. All user data access commands are issued against a QoS domain.\nTypically, a QoS domain will be used by a single application or Flash Translation Layer/block\ndriver/key value driver.\nAn example of how the virtual devices of a SEF Unit could be divided into QoS domains is shown\nin the following figure ",(0,o.kt)("a",{parentName:"p",href:"#fig-QoSDomainExample"},"5"),". A QoS domain is a logical construct that\ndefines a capacity taken from its virtual device\u2019s capacity. It also defines a quota that may exceed\nthe capacity of the virtual device as shown with QoS domains three through four. A SEF Unit can\nhave at most 65534 QoS domains defined. The actual limit depends on the specific hardware."),(0,o.kt)("h4",{id:"fig-QoSDomainExample"},"Figure 5: QoS Domain Example"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"QoS Domain Example",src:a(7117).Z,width:"869",height:"529"})),(0,o.kt)("p",null,"Allocated super blocks are owned by only one QoS domain at a time and are never shared. Super\nblocks are allocated from a shared pool allowing for host-managed thin provisioning. A QoS domain\ncan allocate super blocks until it hits its quota or the free pool is exhausted."),(0,o.kt)("h2",{id:"creation-time-parameters"},"Creation-time Parameters"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"vdHandle"),": the handle to the virtual device the QoS domain will be created in."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"QoSDomainID"),": an identifier that will later be used to specify the created QoS domain. This identifier\nmust be unique across the entire SEF Unit. Valid IDs start at 1 and must be less than or equal\nto \u2018maxQoSDomains\u2018 returned by ",(0,o.kt)("a",{parentName:"p",href:"/SEF-API/SEF_API/sef-api00#function-SEFGetInformation"},"SEFGetInformation"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"flashCapacity"),": the number of 4KiB ADUs reserved for the QoS domain. It supplies a capacity\nand a quota. The capacity is subtracted from the available ADUs from the virtual device so must\nbe less than the currently available ADUs."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"pSLCFlashCapacity"),": the number of 4KiB pSLC ADUs reserved for the QoS domain. It supplies\na capacity and a quota. The capacity is subtracted from the available pSLC ADUs from the virtual\ndevice so must be less than the currently available pSLC ADUs."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"ADUIndex"),": this is the index into the ADUSize[] array in \u2018SEFInfo\u2018 returned by\n",(0,o.kt)("a",{parentName:"p",href:"/SEF-API/SEF_API/sef-api00#function-SEFGetInformation"},"SEFGetInformation")," to select the data and metadata sizes of an\nADU."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"api"),": this field specifies the API to be used for this QoS domain. Currently only the super block\nAPI is supported."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"defectStrategy"),": Specifies how defective ADUs are handled by the QoS domain. The choices are\nPerfect, Packed or Fragmented. The Perfect strategy hides defective ADUs through overprovisioning\nand mapping. Capacity is reserved, and ADUs are remapped to provide static and consistent flash\nmemory addresses with contiguous ADU offsets. Packed also hides defective ADUs presenting\nconsistent flash memory addresses with contiguous ADU offsets, but the size of super blocks will\nshrink as the device wears. With the Fragmented strategy, the client is exposed to the device\u2019s\ndefect management. ADU offsets are non-contiguous, and super blocks will shrink in size as the\ndevice wears. Refer to ",(0,o.kt)("a",{parentName:"p",href:"/SEF-API/addressing#chap-Addressing"},"Addressing")," Chapter for more details."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"recovery"),": Specifies the error recovery strategy for this QoS domain."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"encryption"),": specifies the key the QoS domain is to be encrypted with."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"numPlacementIDs"),": specifies the number of separate, simultaneously opened super blocks that\nmay be used by the QoS domain in auto allocation mode. It does not affect the number of manually\nopened super blocks, which instead depends on the device itself."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"maxOpenSuperBlocks"),": this is the maximum number super blocks that can be open in a QoS\ndomain. If less than numPlacementIDs it will be set to numPlacementIDs+2. This affects resource\nand memory usage in the device."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"defaultReadQueue"),": specifies the default read queue to use for read I/O operations. This can\nbe optionally overridden when submitting I/O to a QoS domain. Read queues are defined by the\nvirtual device and shared by the QoS domains defined in the same virtual device."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"weights"),": Specifies the default weights for erase and program."))}m.isMDXComponent=!0},7117:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/qos-domain-example-81360f797e8c079f8473026aa42eb26d.png"}}]);