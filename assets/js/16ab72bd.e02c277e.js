"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[2682],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>c});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var p=r.createContext({}),d=function(e){var t=r.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=d(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},s=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,p=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=d(a),s=n,c=u["".concat(p,".").concat(s)]||u[s]||k[s]||l;return a?r.createElement(c,o(o({ref:t},m),{},{components:a})):r.createElement(c,o({ref:t},m))}));function c(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,o=new Array(l);o[0]=s;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[u]="string"==typeof e?e:n,o[1]=i;for(var d=2;d<l;d++)o[d]=a[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}s.displayName="MDXCreateElement"},4046:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>k,frontMatter:()=>l,metadata:()=>i,toc:()=>d});var r=a(7462),n=(a(7294),a(3905));const l={},o="Enumerated Types",i={unversionedId:"SEF_API/sef-api05",id:"SEF_API/sef-api05",title:"Enumerated Types",description:"SEFDefectManagementMethod",source:"@site/docs/SEF_API/sef-api05.md",sourceDirName:"SEF_API",slug:"/SEF_API/sef-api05",permalink:"/SEF-API/SEF_API/sef-api05",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Events",permalink:"/SEF-API/SEF_API/sef-api04"}},p={},d=[{value:"SEFDefectManagementMethod",id:"enum-SEFDefectManagementMethod",level:2},{value:"Members of SEFDefectManagementMethod",id:"members-of-sefdefectmanagementmethod",level:4},{value:"SEFAPIIdentifier",id:"enum-SEFAPIIdentifier",level:2},{value:"Members of SEFAPIIdentifier",id:"members-of-sefapiidentifier",level:4},{value:"SEFErrorRecoveryMode",id:"enum-SEFErrorRecoveryMode",level:2},{value:"Members of SEFErrorRecoveryMode",id:"members-of-seferrorrecoverymode",level:4},{value:"SEFDeadlineType",id:"enum-SEFDeadlineType",level:2},{value:"Members of SEFDeadlineType",id:"members-of-sefdeadlinetype",level:4},{value:"SEFNotificationType",id:"enum-SEFNotificationType",level:2},{value:"Members of SEFNotificationType",id:"members-of-sefnotificationtype",level:4},{value:"SEFSuperBlockType",id:"enum-SEFSuperBlockType",level:2},{value:"Members of SEFSuperBlockType",id:"members-of-sefsuperblocktype",level:4},{value:"SEFSuperBlockState",id:"enum-SEFSuperBlockState",level:2},{value:"Members of SEFSuperBlockState",id:"members-of-sefsuperblockstate",level:4},{value:"SEFDataIntegrity",id:"enum-SEFDataIntegrity",level:2},{value:"Members of SEFDataIntegrity",id:"members-of-sefdataintegrity",level:4},{value:"SEFPropertyID",id:"enum-SEFPropertyID",level:2},{value:"Members of SEFPropertyID",id:"members-of-sefpropertyid",level:4},{value:"SEFPropertyType",id:"enum-SEFPropertyType",level:2},{value:"Members of SEFPropertyType",id:"members-of-sefpropertytype",level:4},{value:"SEFCopySourceType",id:"enum-SEFCopySourceType",level:2},{value:"Members of SEFCopySourceType",id:"members-of-sefcopysourcetype",level:4},{value:"SEFIOCBFlags",id:"enum-SEFIOCBFlags",level:2},{value:"Members of SEFIOCBFlags",id:"members-of-sefiocbflags",level:4}],m={toc:d},u="wrapper";function k(e){let{components:t,...a}=e;return(0,n.kt)(u,(0,r.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"enumerated-types"},"Enumerated Types"),(0,n.kt)("h2",{id:"enum-SEFDefectManagementMethod"},"SEFDefectManagementMethod"),(0,n.kt)("h4",{id:"members-of-sefdefectmanagementmethod"},"Members of SEFDefectManagementMethod"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kPacked"),(0,n.kt)("td",{parentName:"tr",align:null},"Offset address in a super block is consecutive. Size of super block is reduced with defected block(s). This results in slower reads due to the extra level of indirection incurred.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kFragmented"),(0,n.kt)("td",{parentName:"tr",align:null},"Defective blocks are left in place, and are simply marked as non-addressable. Over time, this can result in a device with a gradually decreasing usable size. This scheme has the fastest read performance, but comes at the cost of additional management complexity that the host will be responsible for.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kPerfect"),(0,n.kt)("td",{parentName:"tr",align:null},"Offset address is consecutive. Size of super block is fixed. Number of super blocks is reduced with defected block(s). This has the slowest read performance because this remapping has the potential to cross block boundaries")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFAPIIdentifier"},"SEFAPIIdentifier"),(0,n.kt)("h4",{id:"members-of-sefapiidentifier"},"Members of SEFAPIIdentifier"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSuperBlock"),(0,n.kt)("td",{parentName:"tr",align:null},"Currently the only mode supported by the API")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kInDriveGC"),(0,n.kt)("td",{parentName:"tr",align:null},"Reserved for future use")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kVirtualSSD"),(0,n.kt)("td",{parentName:"tr",align:null},"Reserved for future use")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFErrorRecoveryMode"},"SEFErrorRecoveryMode"),(0,n.kt)("h4",{id:"members-of-seferrorrecoverymode"},"Members of SEFErrorRecoveryMode"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kAutomatic"),(0,n.kt)("td",{parentName:"tr",align:null},"Automatic recovery mode")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kHostControlled"),(0,n.kt)("td",{parentName:"tr",align:null},"Host is responsible for recovery")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFDeadlineType"},"SEFDeadlineType"),(0,n.kt)("h4",{id:"members-of-sefdeadlinetype"},"Members of SEFDeadlineType"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kFastest"),(0,n.kt)("td",{parentName:"tr",align:null},"Does not attempt a corrective action, but instead sends a notification to allow higher layer to read from a separate redundant store.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kTypical"),(0,n.kt)("td",{parentName:"tr",align:null},"Attempts to perform basic error recovery in the event of a read error condition")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kLong"),(0,n.kt)("td",{parentName:"tr",align:null},"Attempts to perform more advanced error recovery in the event of a read error condition")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kHeroic"),(0,n.kt)("td",{parentName:"tr",align:null},"Attempts to perform full recovery in the event of a read error condition")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFNotificationType"},"SEFNotificationType"),(0,n.kt)("p",null,"Asynchronous notifications from SEF. "),(0,n.kt)("h4",{id:"members-of-sefnotificationtype"},"Members of SEFNotificationType"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kAddressUpdate"),(0,n.kt)("td",{parentName:"tr",align:null},"The flash address has changed")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kUnflushedData"),(0,n.kt)("td",{parentName:"tr",align:null},"The super block data was flushed to the Flash Memory")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kRequirePatrol"),(0,n.kt)("td",{parentName:"tr",align:null},"The super block requires to be patrolled; A list of super blocks requiring patrol can be retrieved using SEFGetCheckList ",(0,n.kt)("linebreak",null))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kRequireMaintenance"),(0,n.kt)("td",{parentName:"tr",align:null},"The super block requires maintenance; In other words, the data should be copied off and the super block should be freed")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kReducedCapacity"),(0,n.kt)("td",{parentName:"tr",align:null},"The Virtual Device's capacity has been reduced")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kUnreadableData"),(0,n.kt)("td",{parentName:"tr",align:null},"The data stored at the flash address cannot be read")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSuperBlockStateChanged"),(0,n.kt)("td",{parentName:"tr",align:null},"The super block's state has changed")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kOutOfCapacity"),(0,n.kt)("td",{parentName:"tr",align:null},"The Virtual Device is full")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kOutOfPSLCCapacity"),(0,n.kt)("td",{parentName:"tr",align:null},"The Virtual Device is out of pSLC")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kBufferRelease"),(0,n.kt)("td",{parentName:"tr",align:null},"The buffer pointed to by iov can be freed")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFSuperBlockType"},"SEFSuperBlockType"),(0,n.kt)("h4",{id:"members-of-sefsuperblocktype"},"Members of SEFSuperBlockType"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kForWrite"),(0,n.kt)("td",{parentName:"tr",align:null},"Super block is for writes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kForPSLCWrite"),(0,n.kt)("td",{parentName:"tr",align:null},"Super block is for pSLC writes")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFSuperBlockState"},"SEFSuperBlockState"),(0,n.kt)("h4",{id:"members-of-sefsuperblockstate"},"Members of SEFSuperBlockState"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSuperBlockClosed"),(0,n.kt)("td",{parentName:"tr",align:null},"This is the state of super blocks which retain effective data after all super pages have been programmed")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSuperBlockOpenedByErase"),(0,n.kt)("td",{parentName:"tr",align:null},"This is the state of super blocks in the middle of being programmed and were allocated by SEFAllocateSuperBlock()")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSuperBlockOpenedByPlacementId"),(0,n.kt)("td",{parentName:"tr",align:null},"This is the state of super blocks in the middle of being programmed and were allocated automatically by placement id")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFDataIntegrity"},"SEFDataIntegrity"),(0,n.kt)("p",null,"Integrity of a super block. "),(0,n.kt)("h4",{id:"members-of-sefdataintegrity"},"Members of SEFDataIntegrity"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefIntegretyUnknown"),(0,n.kt)("td",{parentName:"tr",align:null},"The block needs to be patrolled")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefIntegretyGood"),(0,n.kt)("td",{parentName:"tr",align:null},"Reading the block requires little to no error correction")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefIntegretyAllowable"),(0,n.kt)("td",{parentName:"tr",align:null},"Reading the block requires an acceptable amount of error correction")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefIntegretyMarginal"),(0,n.kt)("td",{parentName:"tr",align:null},"The data in the block needs to be relocated")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFPropertyID"},"SEFPropertyID"),(0,n.kt)("h4",{id:"members-of-sefpropertyid"},"Members of SEFPropertyID"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyQoSDomainID"),(0,n.kt)("td",{parentName:"tr",align:null},"Get QoS Domain ID in qosID")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyVirtualDeviceID"),(0,n.kt)("td",{parentName:"tr",align:null},"Get Virtual Device ID as vdID")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyUnitNumber"),(0,n.kt)("td",{parentName:"tr",align:null},"Get Unit number as intVal")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyQoSNotify"),(0,n.kt)("td",{parentName:"tr",align:null},"Get QoS notification fnc as qosNotify")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyPrivateData"),(0,n.kt)("td",{parentName:"tr",align:null},"Get/Set private data")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyNumActiveRequests"),(0,n.kt)("td",{parentName:"tr",align:null},"Get Number of active requests as intVal")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFPropertyType"},"SEFPropertyType"),(0,n.kt)("h4",{id:"members-of-sefpropertytype"},"Members of SEFPropertyType"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyTypeInvalid"),(0,n.kt)("td",{parentName:"tr",align:null},"The SEFPropertyID is not supported")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyTypeNull"),(0,n.kt)("td",{parentName:"tr",align:null},"The Property has no value (not set)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyTypeInt"),(0,n.kt)("td",{parentName:"tr",align:null},"The intVal member is valid")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyTypePtr"),(0,n.kt)("td",{parentName:"tr",align:null},"The ptr member is valid")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyTypeQoSDomainID"),(0,n.kt)("td",{parentName:"tr",align:null},"The qosID member is valid")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyTypeVirtualDeviceID"),(0,n.kt)("td",{parentName:"tr",align:null},"The vdID member is valid")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefPropertyTypeQoSNotify"),(0,n.kt)("td",{parentName:"tr",align:null},"The qosNotify member is valid")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFCopySourceType"},"SEFCopySourceType"),(0,n.kt)("p",null,"The source format to be used when copying a super block. "),(0,n.kt)("h4",{id:"members-of-sefcopysourcetype"},"Members of SEFCopySourceType"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kBitmap"),(0,n.kt)("td",{parentName:"tr",align:null},"Use validBitmap as the copy source")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kList"),(0,n.kt)("td",{parentName:"tr",align:null},"Use flashAddressList as the copy source")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"enum-SEFIOCBFlags"},"SEFIOCBFlags"),(0,n.kt)("h4",{id:"members-of-sefiocbflags"},"Members of SEFIOCBFlags"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Member"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefIoFlagDone"),(0,n.kt)("td",{parentName:"tr",align:null},"Flag for polled I/O - library sets this bit to a 1 value once the command completes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefIoFlagNotifyBufferRelease"),(0,n.kt)("td",{parentName:"tr",align:null},"Flag set to indicate caller is managing buffer lifetime. See Also: SEFWriteWithoutPhysicalAddress()")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefIoFlagCommit"),(0,n.kt)("td",{parentName:"tr",align:null},"Flag set to force data to flash before completing, potentially adding padding")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"kSefIoFlagOverride"),(0,n.kt)("td",{parentName:"tr",align:null},"Flag set to apply weight override to i/o")))),(0,n.kt)("hr",null))}k.isMDXComponent=!0}}]);