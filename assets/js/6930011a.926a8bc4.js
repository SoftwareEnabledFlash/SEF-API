"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[591],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return u}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=d(n),u=a,f=p["".concat(l,".").concat(u)]||p[u]||c[u]||o;return n?r.createElement(f,i(i({ref:t},m),{},{components:n})):r.createElement(f,i({ref:t},m))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},157:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return c}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:2},l="Definitions and Acronyms",d={unversionedId:"definitions",id:"version-1.10/definitions",title:"Definitions and Acronyms",description:"| Terms/Acronyms | Definition |",source:"@site/versioned_docs/version-1.10/definitions.md",sourceDirName:".",slug:"/definitions",permalink:"/SEF-API/1.10/definitions",draft:!1,tags:[],version:"1.10",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/SEF-API/1.10/"},next:{title:"Design Environment",permalink:"/SEF-API/1.10/environment"}},m={},c=[],p={toc:c};function u(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"definitions-and-acronyms"},"Definitions and Acronyms"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Terms/Acronyms"),(0,o.kt)("th",{parentName:"tr",align:null},"Definition"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Software-Enabled Flash\u2122 (SEF)"),(0,o.kt)("td",{parentName:"tr",align:null},"A flash memory-based storage hardware platform that is driven by software.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"SEF Unit"),(0,o.kt)("td",{parentName:"tr",align:null},"A PCIe\xae flash memory storage device. Contains one or more flash memory dies and provides flash memory service functions. The SEF Unit command set consists of a subset of the NVMe\u2122 command set with some extensions.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Flash Translation Layer (FTL)"),(0,o.kt)("td",{parentName:"tr",align:null},"A mapping of Logical Block Addresses (LBA) to flash memory addresses providing a hard disk-like API on top of a flash memory API.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Virtual Device (VD)"),(0,o.kt)("td",{parentName:"tr",align:null},"A set of flash memory dies. Occupies one or more flash memory dies, provides one or more QoS domains and wear leveling service between QoS domains. Flash memory dies can only be assigned to one virtual device; they are never shared between virtual devices. Virtual devices provide true hardware-based isolation.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"QoS Domain (QD)"),(0,o.kt)("td",{parentName:"tr",align:null},"A logical construct exposed to the host and enumerated as a SEF device node. QoS domains are created within a single virtual device, and draw super blocks from a common pool within the virtual device. Many QoS domains may be created within a single virtual device. QoS domains provide software\x02based isolation, impose quotas on capacity, and are comprised of a set of super blocks within a virtual device. Super blocks are not shared between QoS domains. Read/write commands are issued to a specific QoS domain.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Super block"),(0,o.kt)("td",{parentName:"tr",align:null},"A set of flash memory blocks spanning all of the dies in a virtual device. All flash memory blocks in a super block can be programmed and read in parallel.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Logical Block Address (LBA)"),(0,o.kt)("td",{parentName:"tr",align:null},"Represents one component of an optional user-visible address\x02ing interface implemented by an FTL.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"ADU"),(0,o.kt)("td",{parentName:"tr",align:null},"Atomic data unit. A SEF-defined internal representation of abstract storage that is the minimum read/write quanta (analogous to the block size of a traditional block device). A SEF Unit may support multiple ADU sizes and the ADU size is specified when creating a QoS domain. The minimum ADU size is 4096 bytes. User Address Eight bytes of arbitrary metadata that is stored with an ADU. For block storage applications, this is typically the LBA. However the SEF Unit makes no assumptions about the format of this data for non-block storage applications.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Placement ID"),(0,o.kt)("td",{parentName:"tr",align:null},"A placement ID is used when writing data to a QoS domain. It\u2019s used to group data of similar lifetime together. ADUs written with the same placement ID are stored in the same super blocks.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"FMQ"),(0,o.kt)("td",{parentName:"tr",align:null},"Flash memory media queues allow for the control of I/O scheduling in a virtual device.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Root Pointer"),(0,o.kt)("td",{parentName:"tr",align:null},"Provides a bootstrapping mechanism to retrieve metadata from a QoS domain.")))))}u.isMDXComponent=!0}}]);