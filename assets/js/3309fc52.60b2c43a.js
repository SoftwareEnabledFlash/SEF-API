"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[7588],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,k=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(k,i(i({ref:t},c),{},{components:n})):a.createElement(k,i({ref:t},c))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7803:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:8},i="Super Blocks",s={unversionedId:"super-blocks",id:"super-blocks",title:"Super Blocks",description:"chap-SuperBlock}",source:"@site/docs/super-blocks.md",sourceDirName:".",slug:"/super-blocks",permalink:"/SEF-API/super-blocks",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"docs",previous:{title:"Super Pages",permalink:"/SEF-API/super-pages"},next:{title:"Delayed Writes",permalink:"/SEF-API/delayed-writes"}},l={},p=[{value:"Super Block Management Commands",id:"super-block-management-commands",level:2},{value:"Figure 6: Super Block State Transitions",id:"fig-SuperBlockStateTransitions",level:4}],c={toc:p},u="wrapper";function d(e){let{components:t,...o}=e;return(0,r.kt)(u,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"chap-SuperBlock"},"Super Blocks"),(0,r.kt)("p",null,"Super blocks are the main units of allocation used within the SEF API. By default, super blocks\nspan all the dies within a single virtual device. However, the size of the super block may be changed\nprior to creating any QoS Domains. The number of super pages in a super block is fixed and is the\nsame as the number of pages in a flash die. The size of a super block, however, is dependent on\nthe configuration of the virtual device that it resides in. A super block can only be a member of a\nsingle QoS domain at any point in time. A super block can only be assigned to a different QoS\ndomain after it has been released."),(0,r.kt)("p",null,"When an erase or allocation occurs within a QoS domain, it is performed in units of super\nblocks."),(0,r.kt)("h2",{id:"super-block-management-commands"},"Super Block Management Commands"),(0,r.kt)("p",null,"Super block management commands consist of three functions: ",(0,r.kt)("inlineCode",{parentName:"p"},"Allocate"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Close")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Release"),".\nSuper block data commands consist of the commands ",(0,r.kt)("inlineCode",{parentName:"p"},"Write")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Copy"),". Each command affects\nstate conditions of the super block. Figure ",(0,r.kt)("a",{parentName:"p",href:"#fig-SuperBlockStateTransitions"},"6")," shows the state\ntransitions regarding super blocks."),(0,r.kt)("p",null,"Super blocks are allocated either explicitly by the ",(0,r.kt)("inlineCode",{parentName:"p"},"Allocate")," command, or implicitly by the ",(0,r.kt)("inlineCode",{parentName:"p"},"Write"),"\ncommand. When the reserved flash memory address ",(0,r.kt)("a",{parentName:"p",href:"/SEF-API/SEF_API/sef-api02#macro-SEFAutoAllocate"},"SEFAutoAllocate"),"\nis specified in a ",(0,r.kt)("inlineCode",{parentName:"p"},"Write")," command, SEF will check if a super block has been allocated for the\ncorresponding placement ID; if not and the QoS domain has not exceeded its capacity limit, a\nnew super block will automatically be allocated and assigned to the placement ID. When a ",(0,r.kt)("inlineCode",{parentName:"p"},"Write"),"\ncommand with the reserved flash memory address extends past the end of the current automatically\nopened super block, a new super block will be allocated (assuming the capacity limit is not exceeded)\nonce the current super block is filled."),(0,r.kt)("p",null,"The host does not need to erase super blocks. When the defect strategy is packed or\nfragmented, the apparent size of the super block may shrink after it is erased. This\naffects ",(0,r.kt)("a",{parentName:"p",href:"/SEF-API/SEF_API/sef-api01#function-SEFWriteWithoutPhysicalAddress"},"SEFWriteWithoutPhysicalAddress"),",\n",(0,r.kt)("a",{parentName:"p",href:"/SEF-API/SEF_API/sef-api00#function-SEFGetSuperBlockInfo"},"SEFGetSuperBlockInfo")," and ",(0,r.kt)("a",{parentName:"p",href:"/SEF-API/SEF_API/sef-api00#function-SEFAllocateSuperBlock"},"SEFAllocateSuperBlock"),"\nThe number of available ADUs may also shrink as the super block is programmed."),(0,r.kt)("h4",{id:"fig-SuperBlockStateTransitions"},"Figure 6: Super Block State Transitions"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Super Block State Transitions",src:n(9893).Z,width:"949",height:"429"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Free State")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Free")," is the initial state for super blocks. ",(0,r.kt)("inlineCode",{parentName:"p"},"Free")," super blocks belong to the free pool owned by a\nVirtual Device."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Closed")," super blocks transit to ",(0,r.kt)("inlineCode",{parentName:"p"},"Free")," upon the Release command."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Open State")),(0,r.kt)("p",null,"This is the state of super blocks in the middle of being programmed. ",(0,r.kt)("inlineCode",{parentName:"p"},"Free")," super blocks transit to\n",(0,r.kt)("inlineCode",{parentName:"p"},"Open")," by either the Allocate or Write Without Physical Address command."),(0,r.kt)("p",null,"There are two sub-states of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Open")," states:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Open       for   Write   Without   Physical   Address"),":    A   super   block   dedicated   to\n",(0,r.kt)("a",{parentName:"p",href:"/SEF-API/SEF_API/sef-api01#function-SEFWriteWithoutPhysicalAddress"},"SEFWriteWithoutPhysicalAddress"),". The su-\nper block transits to this state via a Nameless Write command without explicit super block\nID. The number of super blocks that can exist in this state is determined by the ",(0,r.kt)("inlineCode",{parentName:"p"},"placementID"),"\nparameter at the time of creation for a QoS domain.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Open by Erase"),": A super block opened by the super block management command\n",(0,r.kt)("a",{parentName:"p",href:"/SEF-API/SEF_API/sef-api00#function-SEFAllocateSuperBlock"},"SEFAllocateSuperBlock"),". This super block can be used\nas a destination for Nameless copy and by Nameless Write by specifying an explicit super\nblock ID."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Closed")),(0,r.kt)("p",null,"This is the state of super blocks which retain effective data after all Super Pages have been\nprogrammed. ",(0,r.kt)("inlineCode",{parentName:"p"},"Open")," super blocks transit to ",(0,r.kt)("inlineCode",{parentName:"p"},"Closed")," by either a Nameless Write command, a\nNameless Copy command, an explicit Close command, an explicit Flush command or a device-\ninitiated automatic flush or close."))}d.isMDXComponent=!0},9893:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/superblock-state-transitions-0e87fc9efcdd0215a900691e077921c0.png"}}]);