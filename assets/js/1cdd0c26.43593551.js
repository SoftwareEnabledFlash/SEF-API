"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[7900],{3905:(t,e,a)=>{a.d(e,{Zo:()=>u,kt:()=>c});var r=a(7294);function n(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,r)}return a}function s(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){n(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function i(t,e){if(null==t)return{};var a,r,n=function(t,e){if(null==t)return{};var a,r,n={},l=Object.keys(t);for(r=0;r<l.length;r++)a=l[r],e.indexOf(a)>=0||(n[a]=t[a]);return n}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(r=0;r<l.length;r++)a=l[r],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(n[a]=t[a])}return n}var d=r.createContext({}),o=function(t){var e=r.useContext(d),a=e;return t&&(a="function"==typeof t?t(e):s(s({},e),t)),a},u=function(t){var e=o(t.components);return r.createElement(d.Provider,{value:e},t.children)},p="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},h=r.forwardRef((function(t,e){var a=t.components,n=t.mdxType,l=t.originalType,d=t.parentName,u=i(t,["components","mdxType","originalType","parentName"]),p=o(a),h=n,c=p["".concat(d,".").concat(h)]||p[h]||m[h]||l;return a?r.createElement(c,s(s({ref:e},u),{},{components:a})):r.createElement(c,s({ref:e},u))}));function c(t,e){var a=arguments,n=e&&e.mdxType;if("string"==typeof t||n){var l=a.length,s=new Array(l);s[0]=h;var i={};for(var d in e)hasOwnProperty.call(e,d)&&(i[d]=e[d]);i.originalType=t,i[p]="string"==typeof t?t:n,s[1]=i;for(var o=2;o<l;o++)s[o]=a[o];return r.createElement.apply(null,s)}return r.createElement.apply(null,a)}h.displayName="MDXCreateElement"},5447:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>o});var r=a(7462),n=(a(7294),a(3905));const l={},s="Data Access Commands",i={unversionedId:"SEF_API/sef-api01",id:"version-1.13/SEF_API/sef-api01",title:"Data Access Commands",description:"SEFWriteWithoutPhysicalAddress",source:"@site/versioned_docs/version-1.13/SEF_API/sef-api01.md",sourceDirName:"SEF_API",slug:"/SEF_API/sef-api01",permalink:"/SEF-API/1.13/SEF_API/sef-api01",draft:!1,tags:[],version:"1.13",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"API Management Commands",permalink:"/SEF-API/1.13/SEF_API/sef-api00"},next:{title:"Common Structures",permalink:"/SEF-API/1.13/SEF_API/sef-api02"}},d={},o=[{value:"SEFWriteWithoutPhysicalAddress",id:"function-SEFWriteWithoutPhysicalAddress",level:2},{value:"Parameters of SEFWriteWithoutPhysicalAddress",id:"parameters-of-sefwritewithoutphysicaladdress",level:4},{value:"Return value of SEFWriteWithoutPhysicalAddress",id:"return-value-of-sefwritewithoutphysicaladdress",level:4},{value:"Return values of SEFWriteWithoutPhysicalAddress",id:"return-values-of-sefwritewithoutphysicaladdress",level:4},{value:"SEFReadWithPhysicalAddress",id:"function-SEFReadWithPhysicalAddress",level:2},{value:"Parameters of SEFReadWithPhysicalAddress",id:"parameters-of-sefreadwithphysicaladdress",level:4},{value:"Return value of SEFReadWithPhysicalAddress",id:"return-value-of-sefreadwithphysicaladdress",level:4},{value:"Return values of SEFReadWithPhysicalAddress",id:"return-values-of-sefreadwithphysicaladdress",level:4},{value:"SEFNamelessCopy",id:"function-SEFNamelessCopy",level:2},{value:"Parameters of SEFNamelessCopy",id:"parameters-of-sefnamelesscopy",level:4},{value:"Return value of SEFNamelessCopy",id:"return-value-of-sefnamelesscopy",level:4},{value:"Return values of SEFNamelessCopy",id:"return-values-of-sefnamelesscopy",level:4},{value:"SEFWriteWithoutPhysicalAddressAsync",id:"function-SEFWriteWithoutPhysicalAddressAsync",level:2},{value:"Parameters of SEFWriteWithoutPhysicalAddressAsync",id:"parameters-of-sefwritewithoutphysicaladdressasync",level:4},{value:"SEFReadWithPhysicalAddressAsync",id:"function-SEFReadWithPhysicalAddressAsync",level:2},{value:"Parameters of SEFReadWithPhysicalAddressAsync",id:"parameters-of-sefreadwithphysicaladdressasync",level:4},{value:"SEFNamelessCopyAsync",id:"function-SEFNamelessCopyAsync",level:2},{value:"Parameters of SEFNamelessCopyAsync",id:"parameters-of-sefnamelesscopyasync",level:4}],u={toc:o},p="wrapper";function m(t){let{components:e,...a}=t;return(0,n.kt)(p,(0,r.Z)({},u,a,{components:e,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"data-access-commands"},"Data Access Commands"),(0,n.kt)("h2",{id:"function-SEFWriteWithoutPhysicalAddress"},"SEFWriteWithoutPhysicalAddress"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"struct SEFStatus SEFWriteWithoutPhysicalAddress(SEFQoSHandle qosHandle, struct SEFFlashAddress flashAddress, struct SEFPlacementID placementID, struct SEFUserAddress userAddress, uint32_t numADU, const struct iovec *iov, uint16_t iovcnt, const void *metadata, struct SEFFlashAddress *permanentAddresses, uint32_t *distanceToEndOfSuperBlock, const struct SEFWriteOverrides *overrides)\n")),(0,n.kt)("p",null,"Writes data to the specified user address to an underlying physical flash page that is assigned for the QoS Domain.\nIf auto-allocate is enabled for the super block, when the assigned super block is filled and closed, the SEF Unit assigns a new super block for the remaining writes. If auto-allocate is not enabled, host software will know about the super block size as part of the allocation, and can use this information to construct appropriately-sized write commands. This call will not return until the data has been persisted, and will automatically pad the user data with dummy data if required to complete flash memory programming.\nThe userAddress supplied here will be checked when reading the data back with SEFReadWithPhysicalAddress(). If storing a user address is not required, a userAddress of SEFUserAddressIgnore may be used. The check can optionally be disabled when reading and must be disabled to read data written with a user address of SEFUserAddressIgnore. In kSuperBlock mode and writing multiple ADUs, the LBA portion of the user address is incremented for each ADU. The write will fail if the userAddress is incremented to a value equal to SEFUserAddressIgnore. The userAddresses in a super block can be read using SEFGetUserAddressList.\nNote: The synchronous and asynchronous versions differ in how data is committed to flash. As described above, the synchronous version flushes data to flash returning permanent flash addresses.\nIn contrast, the asynchronous version lazily flushes data to flash. The flash addresses returned are tentative instead. Once the SEF Unit eventually flushes a tentative address to flash, the original address may be discovered to be bad. When this happens, a kAddressUpdate QoS Domain notification is sent indicating the data has moved to a new permanent flash address. When the IOCB flag kSefIoFlagNotifyBufferRelease is set, the domain notification kBufferRelease will be sent for each piece of the IOCB iov as it becomes committed to flash. It is then the responsibility of the caller to maintain the lifetime of the iov buffers until the release notifications are sent. When not set, the commit state can be inferred instead by the kSuperBlockStateChanged QoS notification for the owning super block. Buffer lifetime is managed by library in this case by copying write data into library managed buffers."),(0,n.kt)("h4",{id:"parameters-of-sefwritewithoutphysicaladdress"},"Parameters of SEFWriteWithoutPhysicalAddress"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Direction"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFFlashAddress"},"struct SEFFlashAddress")),(0,n.kt)("td",{parentName:"tr",align:null},"flashAddress"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Flash address of the super block. SEFAutoAllocate if auto allocate.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFPlacementID"},"struct SEFPlacementID")),(0,n.kt)("td",{parentName:"tr",align:null},"placementID"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Only valid if the flashAddress is auto allocated. A value from 0 to numPlacementIds\u20131 indicating what logical data group to place this data in.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFUserAddress"},"struct SEFUserAddress")),(0,n.kt)("td",{parentName:"tr",align:null},"userAddress"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"FTL can store meta-data related to this operation by this field. For example, storing LBA address to bind to this write operation such as data tags.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"uint32","_","t"),(0,n.kt)("td",{parentName:"tr",align:null},"numADU"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Total amount of write data size calculated in QoS Domain ADUs.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"const struct iovec*"),(0,n.kt)("td",{parentName:"tr",align:null},"iov"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"A pointer to the scatter gather list")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"uint16","_","t"),(0,n.kt)("td",{parentName:"tr",align:null},"iovcnt"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"The number of elements in the scatter gather list")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"const void *"),(0,n.kt)("td",{parentName:"tr",align:null},"metadata"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Pointer to metadata to write with the data; The number of bytes per ADU required is SEFQoSDomainInfo::ADUsize.meta. May be NULL.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFFlashAddress"},"struct SEFFlashAddress*")),(0,n.kt)("td",{parentName:"tr",align:null},"permanentAddresses"),(0,n.kt)("td",{parentName:"tr",align:null},"Out"),(0,n.kt)("td",{parentName:"tr",align:null},"Must allocate space for returned permanent physical addresses equal to 8",(0,n.kt)("em",{parentName:"td"},"length (i.e. 8"),"number of ADUs)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"uint32","_","t *"),(0,n.kt)("td",{parentName:"tr",align:null},"distanceToEndOfSuperBlock"),(0,n.kt)("td",{parentName:"tr",align:null},"Out"),(0,n.kt)("td",{parentName:"tr",align:null},"Indicates remaining size in ADU after this write operation. May be NULL. This is not a guarantee as the block may be forced closed if too many super blocks are open. When this returns 0, the block was closed.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFWriteOverrides"},"const struct SEFWriteOverrides*")),(0,n.kt)("td",{parentName:"tr",align:null},"overrides"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Overrides to scheduler parameters; pointer can be null for none required.")))),(0,n.kt)("h4",{id:"return-value-of-sefwritewithoutphysicaladdress"},"Return value of SEFWriteWithoutPhysicalAddress"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,n.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result. When .error is non-zero, .info is the number of ADUs written.")))),(0,n.kt)("h4",{id:"return-values-of-sefwritewithoutphysicaladdress"},"Return values of SEFWriteWithoutPhysicalAddress"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Error Value"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"-ENODEV"),(0,n.kt)("td",{parentName:"tr",align:null},"The QoS Domain handle is not valid")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"-EPERM"),(0,n.kt)("td",{parentName:"tr",align:null},"The QoS Domain Handle is not open")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"-EINVAL"),(0,n.kt)("td",{parentName:"tr",align:null},"The function parameter is not valid; info returns the parameter index that is not valid")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"-ENOSPC"),(0,n.kt)("td",{parentName:"tr",align:null},"The QoS Domain is out of space")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"function-SEFReadWithPhysicalAddress"},"SEFReadWithPhysicalAddress"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"struct SEFStatus SEFReadWithPhysicalAddress(SEFQoSHandle qosHandle, struct SEFFlashAddress flashAddress, uint32_t numADU, const struct iovec *iov, uint16_t iovcnt, uint32_t iovOffset, struct SEFUserAddress userAddress, void *metadata, const struct SEFReadOverrides *overrides)\n")),(0,n.kt)("p",null,"Reads data from a specified physical address.\nWhile writes are expressed in terms of a placement ID or super block flash addresses, reads are expressed in terms of physical flash addresses. Read commands may interrupt other types of commands. When there is an in-flight flash memory command to the same flash die other than a read command, the in-flight command may be suspended in order to maintain deterministic read latency. If the target physical address is currently in the process of being programmed, data will instead be returned from the write buffer.\nThe userAddress must either match what was stored when the data was written or be SEFUserAddressIgnore to disable checking. In kSuperBlock mode, the LBA portion of the user address is incremented for each ADU in a multi-ADU write.\nNote: When reading data that was just written, a read error will be returned when the data's original flash address has been updated but the notification has yet to be processed by the client. In this case, the caller must retry the read after the flash address change notification has been processed."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"See Also:")," ",(0,n.kt)("a",{parentName:"p",href:"/SEF-API/1.13/SEF_API/sef-api00#function-SEFSetRootPointer"},"SEFSetRootPointer()")," "),(0,n.kt)("h4",{id:"parameters-of-sefreadwithphysicaladdress"},"Parameters of SEFReadWithPhysicalAddress"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Direction"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFFlashAddress"},"struct SEFFlashAddress")),(0,n.kt)("td",{parentName:"tr",align:null},"flashAddress"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Physical address for the read command; When the QoS Domain ID and block number are 0, the ADU offset is the root pointer index for the flash address to read.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"uint32","_","t"),(0,n.kt)("td",{parentName:"tr",align:null},"numADU"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Length of data to read (in ADUs). Maximum allowed is superBlockCapacity.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"const struct iovec*"),(0,n.kt)("td",{parentName:"tr",align:null},"iov"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"A pointer to the scatter gather list")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"uint16","_","t"),(0,n.kt)("td",{parentName:"tr",align:null},"iovcnt"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"The number of elements in the scatter gather list")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"uint32","_","t"),(0,n.kt)("td",{parentName:"tr",align:null},"iovOffset"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Starting byte offset into iov array")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFUserAddress"},"struct SEFUserAddress")),(0,n.kt)("td",{parentName:"tr",align:null},"userAddress"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Stored data by the FTL. It will be validated with what was stored when the data was written except when SEFUserAddressIgnore is supplied")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"void *"),(0,n.kt)("td",{parentName:"tr",align:null},"metadata"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Buffer to receive metadata stored with the data; The number of bytes per ADU required is SEFQoSDomainInfo::ADUsize.meta. May be NULL")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFReadOverrides"},"const struct SEFReadOverrides*")),(0,n.kt)("td",{parentName:"tr",align:null},"overrides"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Overrides to scheduler parameters; pointer can be null for none required.")))),(0,n.kt)("h4",{id:"return-value-of-sefreadwithphysicaladdress"},"Return value of SEFReadWithPhysicalAddress"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,n.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,n.kt)("h4",{id:"return-values-of-sefreadwithphysicaladdress"},"Return values of SEFReadWithPhysicalAddress"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Error Value"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"-ENODEV"),(0,n.kt)("td",{parentName:"tr",align:null},"The QoS Domain handle is not valid")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"-EPERM"),(0,n.kt)("td",{parentName:"tr",align:null},"The QoS Domain Handle is not open")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"-EINVAL"),(0,n.kt)("td",{parentName:"tr",align:null},"The function parameter is not valid; info returns the parameter index that is not valid")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"function-SEFNamelessCopy"},"SEFNamelessCopy"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"struct SEFStatus SEFNamelessCopy(SEFQoSHandle srcQosHandle, struct SEFCopySource copySource, SEFQoSHandle dstQosHandle, struct SEFFlashAddress copyDestination, const struct SEFUserAddressFilter *filter, const struct SEFCopyOverrides *overrides, uint32_t numAddressChangeRecords, struct SEFAddressChangeRequest *addressChangeInfo)\n")),(0,n.kt)("p",null,"Performs Nameless Copy with map or list; optional user address filtering.\nCopies ADUs as described by copySource to the copyDestination. Source addresses can only reference closed superblocks."),(0,n.kt)("h4",{id:"parameters-of-sefnamelesscopy"},"Parameters of SEFNamelessCopy"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Direction"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"srcQosHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Handle to the source QoS Domain")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFCopySource"},"struct SEFCopySource")),(0,n.kt)("td",{parentName:"tr",align:null},"copySource"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Physical addresses to copy")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"dstQosHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Handle to the destination QoS Domain")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFFlashAddress"},"struct SEFFlashAddress")),(0,n.kt)("td",{parentName:"tr",align:null},"copyDestination"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Flash address of destination super block")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFUserAddressFilter"},"const struct SEFUserAddressFilter*")),(0,n.kt)("td",{parentName:"tr",align:null},"filter"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Pointer to user address filter parameters, null indicates no filtering")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFCopyOverrides"},"const struct SEFCopyOverrides*")),(0,n.kt)("td",{parentName:"tr",align:null},"overrides"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Pointer to overrides to scheduler parameters; pointer can be null for none required.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"uint32","_","t"),(0,n.kt)("td",{parentName:"tr",align:null},"numAddressChangeRecords"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Maximum number of ADUs to copy (size of SEFAddressChangeRequest userAddress array)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api02#struct-SEFAddressChangeRequest"},"struct SEFAddressChangeRequest*")),(0,n.kt)("td",{parentName:"tr",align:null},"addressChangeInfo"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Filled with changed addresses")))),(0,n.kt)("h4",{id:"return-value-of-sefnamelesscopy"},"Return value of SEFNamelessCopy"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,n.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result")))),(0,n.kt)("h4",{id:"return-values-of-sefnamelesscopy"},"Return values of SEFNamelessCopy"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Error Value"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"0"),(0,n.kt)("td",{parentName:"tr",align:null},"the info member contains: Destination super block has defective planes (kCopyDesinationDefectivePlanes), Read error was detected on source (kCopyReadErrorOnSource), Data that is out of User Address range is detected (kCopyFilteredUserAddresses), Destination super block was filled/closed (kCopyClosedDestination), Consumed entire source bitmap or list (kCopyConsumedSource)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"-ENODEV"),(0,n.kt)("td",{parentName:"tr",align:null},"The QoS Domain handle is not valid")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"-EPERM"),(0,n.kt)("td",{parentName:"tr",align:null},"The QoS Domain Handle is not open")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"-EINVAL"),(0,n.kt)("td",{parentName:"tr",align:null},"The function parameter is not valid; info returns the parameter index that is not valid")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"function-SEFWriteWithoutPhysicalAddressAsync"},"SEFWriteWithoutPhysicalAddressAsync"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"void SEFWriteWithoutPhysicalAddressAsync(SEFQoSHandle qosHandle, struct SEFWriteWithoutPhysicalAddressIOCB *iocb)\n")),(0,n.kt)("p",null,"This function is the asynchronous version of SEFWriteWithoutPhysicalAddress().\nNote: When the kSefIoFlagCommit flag is set in the IOCB's flag field, the returned tentative addresses will be permanent, potentially adding padding.\nNote: Any kAddressUpdate and kSuperBlockStateChange QoS notifications for the returned tentative addresses will occur after the iocb completion routine has returned. When no completion routine is set, the caller must handle the race condition of acting on done being set and the notifications being sent."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"See Also:")," ",(0,n.kt)("a",{parentName:"p",href:"/SEF-API/1.13/SEF_API/sef-api01#function-SEFWriteWithoutPhysicalAddress"},"SEFWriteWithoutPhysicalAddress()")," "),(0,n.kt)("h4",{id:"parameters-of-sefwritewithoutphysicaladdressasync"},"Parameters of SEFWriteWithoutPhysicalAddressAsync"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Direction"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api03#struct-SEFWriteWithoutPhysicalAddressIOCB"},"struct SEFWriteWithoutPhysicalAddressIOCB*")),(0,n.kt)("td",{parentName:"tr",align:null},"iocb"),(0,n.kt)("td",{parentName:"tr",align:null},"In/Out"),(0,n.kt)("td",{parentName:"tr",align:null},"For asynchronous response from SEF Library. Unused fields should be set to 0.")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"function-SEFReadWithPhysicalAddressAsync"},"SEFReadWithPhysicalAddressAsync"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"void SEFReadWithPhysicalAddressAsync(SEFQoSHandle qosHandle, struct SEFReadWithPhysicalAddressIOCB *iocb)\n")),(0,n.kt)("p",null,"This function is the asynchronous version of SEFReadWithPhysicalAddress(). "),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"See Also:")," ",(0,n.kt)("a",{parentName:"p",href:"/SEF-API/1.13/SEF_API/sef-api01#function-SEFReadWithPhysicalAddress"},"SEFReadWithPhysicalAddress()")," "),(0,n.kt)("h4",{id:"parameters-of-sefreadwithphysicaladdressasync"},"Parameters of SEFReadWithPhysicalAddressAsync"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Direction"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Handle to the QoS Domain")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api03#struct-SEFReadWithPhysicalAddressIOCB"},"struct SEFReadWithPhysicalAddressIOCB*")),(0,n.kt)("td",{parentName:"tr",align:null},"iocb"),(0,n.kt)("td",{parentName:"tr",align:null},"In/Out"),(0,n.kt)("td",{parentName:"tr",align:null},"For asynchronous response from SEF Library Unused fields should be set to 0.")))),(0,n.kt)("hr",null),(0,n.kt)("h2",{id:"function-SEFNamelessCopyAsync"},"SEFNamelessCopyAsync"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"void SEFNamelessCopyAsync(SEFQoSHandle qosHandle, struct SEFNamelessCopyIOCB *iocb)\n")),(0,n.kt)("p",null,"This function is the asynchronous version of SEFNamelessCopy(). "),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"See Also:")," ",(0,n.kt)("a",{parentName:"p",href:"/SEF-API/1.13/SEF_API/sef-api01#function-SEFNamelessCopy"},"SEFNamelessCopy()")," "),(0,n.kt)("h4",{id:"parameters-of-sefnamelesscopyasync"},"Parameters of SEFNamelessCopyAsync"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Direction"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"SEFQoSHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"qosHandle"),(0,n.kt)("td",{parentName:"tr",align:null},"In"),(0,n.kt)("td",{parentName:"tr",align:null},"Handle to the source QoS Domain")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"/SEF-API/1.13/SEF_API/sef-api03#struct-SEFNamelessCopyIOCB"},"struct SEFNamelessCopyIOCB*")),(0,n.kt)("td",{parentName:"tr",align:null},"iocb"),(0,n.kt)("td",{parentName:"tr",align:null},"In/Out"),(0,n.kt)("td",{parentName:"tr",align:null},"For asynchronous response from SEF Library Unused fields should be set to 0.")))),(0,n.kt)("hr",null))}m.isMDXComponent=!0}}]);